import {
  init_tslib_es6,
  require_error,
  require_runtime,
  tslib_es6_exports
} from "./chunk-QFE7ZBXI.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-WXXH56N5.js";

// node_modules/@shopify/shopify-api/lib/types.js
var require_types = __commonJS({
  "node_modules/@shopify/shopify-api/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BillingReplacementBehavior = exports.BillingInterval = exports.privacyTopics = exports.ClientType = exports.ShopifyHeader = exports.LATEST_API_VERSION = exports.LIBRARY_NAME = exports.ApiVersion = exports.LogSeverity = void 0;
    var LogSeverity;
    (function(LogSeverity2) {
      LogSeverity2[LogSeverity2["Error"] = 0] = "Error";
      LogSeverity2[LogSeverity2["Warning"] = 1] = "Warning";
      LogSeverity2[LogSeverity2["Info"] = 2] = "Info";
      LogSeverity2[LogSeverity2["Debug"] = 3] = "Debug";
    })(LogSeverity || (exports.LogSeverity = LogSeverity = {}));
    var ApiVersion;
    (function(ApiVersion2) {
      ApiVersion2["October22"] = "2022-10";
      ApiVersion2["January23"] = "2023-01";
      ApiVersion2["April23"] = "2023-04";
      ApiVersion2["July23"] = "2023-07";
      ApiVersion2["October23"] = "2023-10";
      ApiVersion2["January24"] = "2024-01";
      ApiVersion2["Unstable"] = "unstable";
    })(ApiVersion || (exports.ApiVersion = ApiVersion = {}));
    exports.LIBRARY_NAME = "Shopify API Library";
    exports.LATEST_API_VERSION = ApiVersion.January24;
    var ShopifyHeader;
    (function(ShopifyHeader2) {
      ShopifyHeader2["AccessToken"] = "X-Shopify-Access-Token";
      ShopifyHeader2["ApiVersion"] = "X-Shopify-API-Version";
      ShopifyHeader2["Domain"] = "X-Shopify-Shop-Domain";
      ShopifyHeader2["Hmac"] = "X-Shopify-Hmac-Sha256";
      ShopifyHeader2["Topic"] = "X-Shopify-Topic";
      ShopifyHeader2["SubTopic"] = "X-Shopify-Sub-Topic";
      ShopifyHeader2["WebhookId"] = "X-Shopify-Webhook-Id";
      ShopifyHeader2["StorefrontPrivateToken"] = "Shopify-Storefront-Private-Token";
      ShopifyHeader2["StorefrontSDKVariant"] = "X-SDK-Variant";
      ShopifyHeader2["StorefrontSDKVersion"] = "X-SDK-Version";
    })(ShopifyHeader || (exports.ShopifyHeader = ShopifyHeader = {}));
    var ClientType;
    (function(ClientType2) {
      ClientType2["Rest"] = "rest";
      ClientType2["Graphql"] = "graphql";
    })(ClientType || (exports.ClientType = ClientType = {}));
    exports.privacyTopics = [
      "CUSTOMERS_DATA_REQUEST",
      "CUSTOMERS_REDACT",
      "SHOP_REDACT"
    ];
    var BillingInterval;
    (function(BillingInterval2) {
      BillingInterval2["OneTime"] = "ONE_TIME";
      BillingInterval2["Every30Days"] = "EVERY_30_DAYS";
      BillingInterval2["Annual"] = "ANNUAL";
      BillingInterval2["Usage"] = "USAGE";
    })(BillingInterval || (exports.BillingInterval = BillingInterval = {}));
    var BillingReplacementBehavior;
    (function(BillingReplacementBehavior2) {
      BillingReplacementBehavior2["ApplyImmediately"] = "APPLY_IMMEDIATELY";
      BillingReplacementBehavior2["ApplyOnNextBillingCycle"] = "APPLY_ON_NEXT_BILLING_CYCLE";
      BillingReplacementBehavior2["Standard"] = "STANDARD";
    })(BillingReplacementBehavior || (exports.BillingReplacementBehavior = BillingReplacementBehavior = {}));
  }
});

// node_modules/@shopify/shopify-api/lib/version.js
var require_version = __commonJS({
  "node_modules/@shopify/shopify-api/lib/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHOPIFY_API_LIBRARY_VERSION = void 0;
    exports.SHOPIFY_API_LIBRARY_VERSION = "9.4.1";
  }
});

// node_modules/compare-versions/lib/esm/utils.js
var semver, validateAndParse, isWildcard, tryParse, forceType, compareStrings, compareSegments;
var init_utils = __esm({
  "node_modules/compare-versions/lib/esm/utils.js"() {
    semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
    validateAndParse = (version) => {
      if (typeof version !== "string") {
        throw new TypeError("Invalid argument expected string");
      }
      const match = version.match(semver);
      if (!match) {
        throw new Error(`Invalid argument not valid semver ('${version}' received)`);
      }
      match.shift();
      return match;
    };
    isWildcard = (s) => s === "*" || s === "x" || s === "X";
    tryParse = (v) => {
      const n = parseInt(v, 10);
      return isNaN(n) ? v : n;
    };
    forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];
    compareStrings = (a, b) => {
      if (isWildcard(a) || isWildcard(b))
        return 0;
      const [ap, bp] = forceType(tryParse(a), tryParse(b));
      if (ap > bp)
        return 1;
      if (ap < bp)
        return -1;
      return 0;
    };
    compareSegments = (a, b) => {
      for (let i = 0; i < Math.max(a.length, b.length); i++) {
        const r = compareStrings(a[i] || "0", b[i] || "0");
        if (r !== 0)
          return r;
      }
      return 0;
    };
  }
});

// node_modules/compare-versions/lib/esm/compareVersions.js
var compareVersions;
var init_compareVersions = __esm({
  "node_modules/compare-versions/lib/esm/compareVersions.js"() {
    init_utils();
    compareVersions = (v1, v2) => {
      const n1 = validateAndParse(v1);
      const n2 = validateAndParse(v2);
      const p1 = n1.pop();
      const p2 = n2.pop();
      const r = compareSegments(n1, n2);
      if (r !== 0)
        return r;
      if (p1 && p2) {
        return compareSegments(p1.split("."), p2.split("."));
      } else if (p1 || p2) {
        return p1 ? -1 : 1;
      }
      return 0;
    };
  }
});

// node_modules/compare-versions/lib/esm/compare.js
var compare, operatorResMap, allowedOperators, assertValidOperator;
var init_compare = __esm({
  "node_modules/compare-versions/lib/esm/compare.js"() {
    init_compareVersions();
    compare = (v1, v2, operator) => {
      assertValidOperator(operator);
      const res = compareVersions(v1, v2);
      return operatorResMap[operator].includes(res);
    };
    operatorResMap = {
      ">": [1],
      ">=": [0, 1],
      "=": [0],
      "<=": [-1, 0],
      "<": [-1],
      "!=": [-1, 1]
    };
    allowedOperators = Object.keys(operatorResMap);
    assertValidOperator = (op) => {
      if (typeof op !== "string") {
        throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);
      }
      if (allowedOperators.indexOf(op) === -1) {
        throw new Error(`Invalid operator, expected one of ${allowedOperators.join("|")}`);
      }
    };
  }
});

// node_modules/compare-versions/lib/esm/satisfies.js
var satisfies;
var init_satisfies = __esm({
  "node_modules/compare-versions/lib/esm/satisfies.js"() {
    init_compare();
    init_utils();
    satisfies = (version, range) => {
      range = range.replace(/([><=]+)\s+/g, "$1");
      if (range.includes("||")) {
        return range.split("||").some((r4) => satisfies(version, r4));
      } else if (range.includes(" - ")) {
        const [a, b] = range.split(" - ", 2);
        return satisfies(version, `>=${a} <=${b}`);
      } else if (range.includes(" ")) {
        return range.trim().replace(/\s{2,}/g, " ").split(" ").every((r4) => satisfies(version, r4));
      }
      const m = range.match(/^([<>=~^]+)/);
      const op = m ? m[1] : "=";
      if (op !== "^" && op !== "~")
        return compare(version, range, op);
      const [v1, v2, v3, , vp] = validateAndParse(version);
      const [r1, r2, r3, , rp] = validateAndParse(range);
      const v = [v1, v2, v3];
      const r = [r1, r2 !== null && r2 !== void 0 ? r2 : "x", r3 !== null && r3 !== void 0 ? r3 : "x"];
      if (rp) {
        if (!vp)
          return false;
        if (compareSegments(v, r) !== 0)
          return false;
        if (compareSegments(vp.split("."), rp.split(".")) === -1)
          return false;
      }
      const nonZero = r.findIndex((v4) => v4 !== "0") + 1;
      const i = op === "~" ? 2 : nonZero > 1 ? nonZero : 1;
      if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0)
        return false;
      if (compareSegments(v.slice(i), r.slice(i)) === -1)
        return false;
      return true;
    };
  }
});

// node_modules/compare-versions/lib/esm/validate.js
var validate, validateStrict;
var init_validate = __esm({
  "node_modules/compare-versions/lib/esm/validate.js"() {
    init_utils();
    validate = (version) => typeof version === "string" && /^[v\d]/.test(version) && semver.test(version);
    validateStrict = (version) => typeof version === "string" && /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/.test(version);
  }
});

// node_modules/compare-versions/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  compare: () => compare,
  compareVersions: () => compareVersions,
  satisfies: () => satisfies,
  validate: () => validate,
  validateStrict: () => validateStrict
});
var init_esm = __esm({
  "node_modules/compare-versions/lib/esm/index.js"() {
    init_compare();
    init_compareVersions();
    init_satisfies();
    init_validate();
  }
});

// node_modules/@shopify/shopify-api/lib/logger/log.js
var require_log = __commonJS({
  "node_modules/@shopify/shopify-api/lib/logger/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.log = void 0;
    var types_1 = require_types();
    function log(config) {
      return function(severity, message, context = {}) {
        if (severity > config.logger.level) {
          return;
        }
        const prefix = [];
        if (config.logger.timestamps) {
          prefix.push(`${(/* @__PURE__ */ new Date()).toISOString().slice(0, -5)}Z`);
        }
        let packageString = context.package || "shopify-api";
        delete context.package;
        switch (severity) {
          case types_1.LogSeverity.Debug:
            packageString = `${packageString}/DEBUG`;
            break;
          case types_1.LogSeverity.Info:
            packageString = `${packageString}/INFO`;
            break;
          case types_1.LogSeverity.Warning:
            packageString = `${packageString}/WARNING`;
            break;
          case types_1.LogSeverity.Error:
            packageString = `${packageString}/ERROR`;
            break;
        }
        prefix.push(packageString);
        const contextParts = [];
        Object.entries(context).forEach(([key, value]) => {
          contextParts.push(`${key}: ${value}`);
        });
        let suffix = "";
        if (contextParts.length > 0) {
          suffix = ` | {${contextParts.join(", ")}}`;
        }
        config.logger.log(severity, `[${prefix.join("] [")}] ${message}${suffix}`);
      };
    }
    exports.log = log;
  }
});

// node_modules/@shopify/shopify-api/lib/logger/index.js
var require_logger = __commonJS({
  "node_modules/@shopify/shopify-api/lib/logger/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logger = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var compare_versions_1 = (init_esm(), __toCommonJS(esm_exports));
    var types_1 = require_types();
    var error_1 = require_error();
    var version_1 = require_version();
    var log_1 = require_log();
    function logger(config) {
      const logFunction = (0, log_1.log)(config);
      return {
        log: logFunction,
        debug: (message, context = {}) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          return logFunction(types_1.LogSeverity.Debug, message, context);
        }),
        info: (message, context = {}) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          return logFunction(types_1.LogSeverity.Info, message, context);
        }),
        warning: (message, context = {}) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          return logFunction(types_1.LogSeverity.Warning, message, context);
        }),
        error: (message, context = {}) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          return logFunction(types_1.LogSeverity.Error, message, context);
        }),
        deprecated: deprecated(logFunction)
      };
    }
    exports.logger = logger;
    function deprecated(logFunction) {
      return function(version, message) {
        if ((0, compare_versions_1.compare)(version_1.SHOPIFY_API_LIBRARY_VERSION, version, ">=")) {
          throw new error_1.FeatureDeprecatedError(`Feature was deprecated in version ${version}`);
        }
        return logFunction(types_1.LogSeverity.Warning, `[Deprecated | ${version}] ${message}`);
      };
    }
  }
});

// node_modules/@shopify/shopify-api/lib/clients/admin/types.js
var require_types2 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/admin/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@shopify/shopify-api/lib/clients/graphql_proxy/types.js
var require_types3 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/graphql_proxy/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@shopify/admin-api-client/dist/graphql-client/dist/graphql-client/constants.mjs
var CLIENT, MIN_RETRIES, MAX_RETRIES, GQL_API_ERROR, UNEXPECTED_CONTENT_TYPE_ERROR, NO_DATA_OR_ERRORS_ERROR, CONTENT_TYPES, SDK_VARIANT_HEADER, SDK_VERSION_HEADER, DEFAULT_SDK_VARIANT, DEFAULT_CLIENT_VERSION, RETRY_WAIT_TIME, RETRIABLE_STATUS_CODES, DEFER_OPERATION_REGEX, NEWLINE_SEPARATOR, BOUNDARY_HEADER_REGEX, HEADER_SEPARATOR;
var init_constants = __esm({
  "node_modules/@shopify/admin-api-client/dist/graphql-client/dist/graphql-client/constants.mjs"() {
    CLIENT = "GraphQL Client";
    MIN_RETRIES = 0;
    MAX_RETRIES = 3;
    GQL_API_ERROR = "An error occurred while fetching from the API. Review 'graphQLErrors' for details.";
    UNEXPECTED_CONTENT_TYPE_ERROR = "Response returned unexpected Content-Type:";
    NO_DATA_OR_ERRORS_ERROR = "An unknown error has occurred. The API did not return a data object or any errors in its response.";
    CONTENT_TYPES = {
      json: "application/json",
      multipart: "multipart/mixed"
    };
    SDK_VARIANT_HEADER = "X-SDK-Variant";
    SDK_VERSION_HEADER = "X-SDK-Version";
    DEFAULT_SDK_VARIANT = "shopify-graphql-client";
    DEFAULT_CLIENT_VERSION = "0.10.2";
    RETRY_WAIT_TIME = 1e3;
    RETRIABLE_STATUS_CODES = [429, 503];
    DEFER_OPERATION_REGEX = /@(defer)\b/i;
    NEWLINE_SEPARATOR = "\r\n";
    BOUNDARY_HEADER_REGEX = /boundary="?([^=";]+)"?/i;
    HEADER_SEPARATOR = NEWLINE_SEPARATOR + NEWLINE_SEPARATOR;
  }
});

// node_modules/@shopify/admin-api-client/dist/graphql-client/dist/graphql-client/utilities.mjs
function formatErrorMessage(message, client = CLIENT) {
  return message.startsWith(`${client}`) ? message : `${client}: ${message}`;
}
function getErrorMessage(error) {
  return error instanceof Error ? error.message : JSON.stringify(error);
}
function getErrorCause(error) {
  return error instanceof Error && error.cause ? error.cause : void 0;
}
function combineErrors(dataArray) {
  return dataArray.flatMap(({ errors }) => {
    return errors ?? [];
  });
}
function validateRetries({ client, retries }) {
  if (retries !== void 0 && (typeof retries !== "number" || retries < MIN_RETRIES || retries > MAX_RETRIES)) {
    throw new Error(`${client}: The provided "retries" value (${retries}) is invalid - it cannot be less than ${MIN_RETRIES} or greater than ${MAX_RETRIES}`);
  }
}
function getKeyValueIfValid(key, value) {
  return value && (typeof value !== "object" || Array.isArray(value) || typeof value === "object" && Object.keys(value).length > 0) ? { [key]: value } : {};
}
function buildDataObjectByPath(path, data) {
  if (path.length === 0) {
    return data;
  }
  const key = path.pop();
  const newData = {
    [key]: data
  };
  if (path.length === 0) {
    return newData;
  }
  return buildDataObjectByPath(path, newData);
}
function combineObjects(baseObject, newObject) {
  return Object.keys(newObject || {}).reduce((acc, key) => {
    if ((typeof newObject[key] === "object" || Array.isArray(newObject[key])) && baseObject[key]) {
      acc[key] = combineObjects(baseObject[key], newObject[key]);
      return acc;
    }
    acc[key] = newObject[key];
    return acc;
  }, Array.isArray(baseObject) ? [...baseObject] : { ...baseObject });
}
function buildCombinedDataObject([initialDatum, ...remainingData]) {
  return remainingData.reduce(combineObjects, { ...initialDatum });
}
var init_utilities = __esm({
  "node_modules/@shopify/admin-api-client/dist/graphql-client/dist/graphql-client/utilities.mjs"() {
    init_constants();
  }
});

// node_modules/@shopify/admin-api-client/dist/graphql-client/dist/graphql-client/http-fetch.mjs
function generateHttpFetch({ clientLogger, customFetchApi = fetch, client = CLIENT, defaultRetryWaitTime = RETRY_WAIT_TIME, retriableCodes = RETRIABLE_STATUS_CODES }) {
  const httpFetch = async (requestParams, count, maxRetries) => {
    const nextCount = count + 1;
    const maxTries = maxRetries + 1;
    let response;
    try {
      response = await customFetchApi(...requestParams);
      clientLogger({
        type: "HTTP-Response",
        content: {
          requestParams,
          response
        }
      });
      if (!response.ok && retriableCodes.includes(response.status) && nextCount <= maxTries) {
        throw new Error();
      }
      return response;
    } catch (error) {
      if (nextCount <= maxTries) {
        const retryAfter = response == null ? void 0 : response.headers.get("Retry-After");
        await sleep(retryAfter ? parseInt(retryAfter, 10) : defaultRetryWaitTime);
        clientLogger({
          type: "HTTP-Retry",
          content: {
            requestParams,
            lastResponse: response,
            retryAttempt: count,
            maxRetries
          }
        });
        return httpFetch(requestParams, nextCount, maxRetries);
      }
      throw new Error(formatErrorMessage(`${maxRetries > 0 ? `Attempted maximum number of ${maxRetries} network retries. Last message - ` : ""}${getErrorMessage(error)}`, client));
    }
  };
  return httpFetch;
}
async function sleep(waitTime) {
  return new Promise((resolve) => setTimeout(resolve, waitTime));
}
var init_http_fetch = __esm({
  "node_modules/@shopify/admin-api-client/dist/graphql-client/dist/graphql-client/http-fetch.mjs"() {
    init_constants();
    init_utilities();
  }
});

// node_modules/@shopify/admin-api-client/dist/graphql-client/dist/graphql-client/graphql-client.mjs
function createGraphQLClient({ headers, url, customFetchApi = fetch, retries = 0, logger }) {
  validateRetries({ client: CLIENT, retries });
  const config = {
    headers,
    url,
    retries
  };
  const clientLogger = generateClientLogger(logger);
  const httpFetch = generateHttpFetch({
    customFetchApi,
    clientLogger,
    defaultRetryWaitTime: RETRY_WAIT_TIME
  });
  const fetch2 = generateFetch(httpFetch, config);
  const request = generateRequest(fetch2);
  const requestStream = generateRequestStream(fetch2);
  return {
    config,
    fetch: fetch2,
    request,
    requestStream
  };
}
function generateClientLogger(logger) {
  return (logContent) => {
    if (logger) {
      logger(logContent);
    }
  };
}
async function processJSONResponse(response) {
  const { errors, data, extensions } = await response.json();
  return {
    ...getKeyValueIfValid("data", data),
    ...getKeyValueIfValid("extensions", extensions),
    ...errors || !data ? {
      errors: {
        networkStatusCode: response.status,
        message: formatErrorMessage(errors ? GQL_API_ERROR : NO_DATA_OR_ERRORS_ERROR),
        ...getKeyValueIfValid("graphQLErrors", errors),
        response
      }
    } : {}
  };
}
function generateFetch(httpFetch, { url, headers, retries }) {
  return async (operation, options = {}) => {
    const { variables, headers: overrideHeaders, url: overrideUrl, retries: overrideRetries } = options;
    const body = JSON.stringify({
      query: operation,
      variables
    });
    validateRetries({ client: CLIENT, retries: overrideRetries });
    const flatHeaders = Object.entries({
      ...headers,
      ...overrideHeaders
    }).reduce((headers2, [key, value]) => {
      headers2[key] = Array.isArray(value) ? value.join(", ") : value.toString();
      return headers2;
    }, {});
    if (!flatHeaders[SDK_VARIANT_HEADER] && !flatHeaders[SDK_VERSION_HEADER]) {
      flatHeaders[SDK_VARIANT_HEADER] = DEFAULT_SDK_VARIANT;
      flatHeaders[SDK_VERSION_HEADER] = DEFAULT_CLIENT_VERSION;
    }
    const fetchParams = [
      overrideUrl ?? url,
      {
        method: "POST",
        headers: flatHeaders,
        body
      }
    ];
    return httpFetch(fetchParams, 1, overrideRetries ?? retries);
  };
}
function generateRequest(fetch2) {
  return async (...props) => {
    if (DEFER_OPERATION_REGEX.test(props[0])) {
      throw new Error(formatErrorMessage("This operation will result in a streamable response - use requestStream() instead."));
    }
    try {
      const response = await fetch2(...props);
      const { status, statusText } = response;
      const contentType = response.headers.get("content-type") || "";
      if (!response.ok) {
        return {
          errors: {
            networkStatusCode: status,
            message: formatErrorMessage(statusText),
            response
          }
        };
      }
      if (!contentType.includes(CONTENT_TYPES.json)) {
        return {
          errors: {
            networkStatusCode: status,
            message: formatErrorMessage(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${contentType}`),
            response
          }
        };
      }
      return processJSONResponse(response);
    } catch (error) {
      return {
        errors: {
          message: getErrorMessage(error)
        }
      };
    }
  };
}
async function* getStreamBodyIterator(response) {
  const decoder = new TextDecoder();
  if (response.body[Symbol.asyncIterator]) {
    for await (const chunk of response.body) {
      yield decoder.decode(chunk);
    }
  } else {
    const reader = response.body.getReader();
    let readResult;
    try {
      while (!(readResult = await reader.read()).done) {
        yield decoder.decode(readResult.value);
      }
    } finally {
      reader.cancel();
    }
  }
}
function readStreamChunk(streamBodyIterator, boundary) {
  return {
    async *[Symbol.asyncIterator]() {
      try {
        let buffer = "";
        for await (const textChunk of streamBodyIterator) {
          buffer += textChunk;
          if (buffer.indexOf(boundary) > -1) {
            const lastBoundaryIndex = buffer.lastIndexOf(boundary);
            const fullResponses = buffer.slice(0, lastBoundaryIndex);
            const chunkBodies = fullResponses.split(boundary).filter((chunk) => chunk.trim().length > 0).map((chunk) => {
              const body = chunk.slice(chunk.indexOf(HEADER_SEPARATOR) + HEADER_SEPARATOR.length).trim();
              return body;
            });
            if (chunkBodies.length > 0) {
              yield chunkBodies;
            }
            buffer = buffer.slice(lastBoundaryIndex + boundary.length);
            if (buffer.trim() === `--`) {
              buffer = "";
            }
          }
        }
      } catch (error) {
        throw new Error(`Error occured while processing stream payload - ${getErrorMessage(error)}`);
      }
    }
  };
}
function createJsonResponseAsyncIterator(response) {
  return {
    async *[Symbol.asyncIterator]() {
      const processedResponse = await processJSONResponse(response);
      yield {
        ...processedResponse,
        hasNext: false
      };
    }
  };
}
function getResponseDataFromChunkBodies(chunkBodies) {
  return chunkBodies.map((value) => {
    try {
      return JSON.parse(value);
    } catch (error) {
      throw new Error(`Error in parsing multipart response - ${getErrorMessage(error)}`);
    }
  }).map((payload) => {
    const { data, incremental, hasNext, extensions, errors } = payload;
    if (!incremental) {
      return {
        data: data || {},
        ...getKeyValueIfValid("errors", errors),
        ...getKeyValueIfValid("extensions", extensions),
        hasNext
      };
    }
    const incrementalArray = incremental.map(({ data: data2, path, errors: errors2 }) => {
      return {
        data: data2 && path ? buildDataObjectByPath(path, data2) : {},
        ...getKeyValueIfValid("errors", errors2)
      };
    });
    return {
      data: incrementalArray.length === 1 ? incrementalArray[0].data : buildCombinedDataObject([
        ...incrementalArray.map(({ data: data2 }) => data2)
      ]),
      ...getKeyValueIfValid("errors", combineErrors(incrementalArray)),
      hasNext
    };
  });
}
function validateResponseData(responseErrors, combinedData) {
  if (responseErrors.length > 0) {
    throw new Error(GQL_API_ERROR, {
      cause: {
        graphQLErrors: responseErrors
      }
    });
  }
  if (Object.keys(combinedData).length === 0) {
    throw new Error(NO_DATA_OR_ERRORS_ERROR);
  }
}
function createMultipartResponseAsyncInterator(response, responseContentType) {
  var _a;
  const boundaryHeader = (responseContentType ?? "").match(BOUNDARY_HEADER_REGEX);
  const boundary = `--${boundaryHeader ? boundaryHeader[1] : "-"}`;
  if (!((_a = response.body) == null ? void 0 : _a.getReader) && !response.body[Symbol.asyncIterator]) {
    throw new Error("API multipart response did not return an iterable body", {
      cause: response
    });
  }
  const streamBodyIterator = getStreamBodyIterator(response);
  let combinedData = {};
  let responseExtensions;
  return {
    async *[Symbol.asyncIterator]() {
      var _a2;
      try {
        let streamHasNext = true;
        for await (const chunkBodies of readStreamChunk(streamBodyIterator, boundary)) {
          const responseData = getResponseDataFromChunkBodies(chunkBodies);
          responseExtensions = ((_a2 = responseData.find((datum) => datum.extensions)) == null ? void 0 : _a2.extensions) ?? responseExtensions;
          const responseErrors = combineErrors(responseData);
          combinedData = buildCombinedDataObject([
            combinedData,
            ...responseData.map(({ data }) => data)
          ]);
          streamHasNext = responseData.slice(-1)[0].hasNext;
          validateResponseData(responseErrors, combinedData);
          yield {
            ...getKeyValueIfValid("data", combinedData),
            ...getKeyValueIfValid("extensions", responseExtensions),
            hasNext: streamHasNext
          };
        }
        if (streamHasNext) {
          throw new Error(`Response stream terminated unexpectedly`);
        }
      } catch (error) {
        const cause = getErrorCause(error);
        yield {
          ...getKeyValueIfValid("data", combinedData),
          ...getKeyValueIfValid("extensions", responseExtensions),
          errors: {
            message: formatErrorMessage(getErrorMessage(error)),
            networkStatusCode: response.status,
            ...getKeyValueIfValid("graphQLErrors", cause == null ? void 0 : cause.graphQLErrors),
            response
          },
          hasNext: false
        };
      }
    }
  };
}
function generateRequestStream(fetch2) {
  return async (...props) => {
    if (!DEFER_OPERATION_REGEX.test(props[0])) {
      throw new Error(formatErrorMessage("This operation does not result in a streamable response - use request() instead."));
    }
    try {
      const response = await fetch2(...props);
      const { statusText } = response;
      if (!response.ok) {
        throw new Error(statusText, { cause: response });
      }
      const responseContentType = response.headers.get("content-type") || "";
      switch (true) {
        case responseContentType.includes(CONTENT_TYPES.json):
          return createJsonResponseAsyncIterator(response);
        case responseContentType.includes(CONTENT_TYPES.multipart):
          return createMultipartResponseAsyncInterator(response, responseContentType);
        default:
          throw new Error(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${responseContentType}`, { cause: response });
      }
    } catch (error) {
      return {
        async *[Symbol.asyncIterator]() {
          const response = getErrorCause(error);
          yield {
            errors: {
              message: formatErrorMessage(getErrorMessage(error)),
              ...getKeyValueIfValid("networkStatusCode", response == null ? void 0 : response.status),
              ...getKeyValueIfValid("response", response)
            },
            hasNext: false
          };
        }
      };
    }
  };
}
var init_graphql_client = __esm({
  "node_modules/@shopify/admin-api-client/dist/graphql-client/dist/graphql-client/graphql-client.mjs"() {
    init_http_fetch();
    init_constants();
    init_utilities();
  }
});

// node_modules/@shopify/admin-api-client/dist/graphql-client/dist/api-client-utilities/validations.mjs
function validateDomainAndGetStoreUrl({ client, storeDomain }) {
  try {
    if (!storeDomain || typeof storeDomain !== "string") {
      throw new Error();
    }
    const trimmedDomain = storeDomain.trim();
    const protocolUrl = trimmedDomain.match(/^https?:/) ? trimmedDomain : `https://${trimmedDomain}`;
    const url = new URL(protocolUrl);
    url.protocol = "https";
    return url.origin;
  } catch (_error) {
    throw new Error(`${client}: a valid store domain ("${storeDomain}") must be provided`);
  }
}
function validateApiVersion({ client, currentSupportedApiVersions, apiVersion, logger }) {
  const versionError = `${client}: the provided apiVersion ("${apiVersion}")`;
  const supportedVersion = `Currently supported API versions: ${currentSupportedApiVersions.join(", ")}`;
  if (!apiVersion || typeof apiVersion !== "string") {
    throw new Error(`${versionError} is invalid. ${supportedVersion}`);
  }
  const trimmedApiVersion = apiVersion.trim();
  if (!currentSupportedApiVersions.includes(trimmedApiVersion)) {
    if (logger) {
      logger({
        type: "Unsupported_Api_Version",
        content: {
          apiVersion,
          supportedApiVersions: currentSupportedApiVersions
        }
      });
    } else {
      console.warn(`${versionError} is likely deprecated or not supported. ${supportedVersion}`);
    }
  }
}
var init_validations = __esm({
  "node_modules/@shopify/admin-api-client/dist/graphql-client/dist/api-client-utilities/validations.mjs"() {
  }
});

// node_modules/@shopify/admin-api-client/dist/graphql-client/dist/api-client-utilities/api-versions.mjs
function getQuarterMonth(quarter) {
  const month = quarter * 3 - 2;
  return month === 10 ? month : `0${month}`;
}
function getPrevousVersion(year, quarter, nQuarter) {
  const versionQuarter = quarter - nQuarter;
  if (versionQuarter <= 0) {
    return `${year - 1}-${getQuarterMonth(versionQuarter + 4)}`;
  }
  return `${year}-${getQuarterMonth(versionQuarter)}`;
}
function getCurrentApiVersion() {
  const date = /* @__PURE__ */ new Date();
  const month = date.getUTCMonth();
  const year = date.getUTCFullYear();
  const quarter = Math.floor(month / 3 + 1);
  return {
    year,
    quarter,
    version: `${year}-${getQuarterMonth(quarter)}`
  };
}
function getCurrentSupportedApiVersions() {
  const { year, quarter, version: currentVersion } = getCurrentApiVersion();
  const nextVersion = quarter === 4 ? `${year + 1}-01` : `${year}-${getQuarterMonth(quarter + 1)}`;
  return [
    getPrevousVersion(year, quarter, 3),
    getPrevousVersion(year, quarter, 2),
    getPrevousVersion(year, quarter, 1),
    currentVersion,
    nextVersion,
    "unstable"
  ];
}
var init_api_versions = __esm({
  "node_modules/@shopify/admin-api-client/dist/graphql-client/dist/api-client-utilities/api-versions.mjs"() {
  }
});

// node_modules/@shopify/admin-api-client/dist/graphql-client/dist/api-client-utilities/utilities.mjs
function generateGetHeaders(config) {
  return (customHeaders) => {
    return { ...customHeaders ?? {}, ...config.headers };
  };
}
function generateGetGQLClientParams({ getHeaders, getApiUrl }) {
  return (operation, options) => {
    const props = [operation];
    if (options && Object.keys(options).length > 0) {
      const { variables, apiVersion: propApiVersion, headers, retries } = options;
      props.push({
        ...variables ? { variables } : {},
        ...headers ? { headers: getHeaders(headers) } : {},
        ...propApiVersion ? { url: getApiUrl(propApiVersion) } : {},
        ...retries ? { retries } : {}
      });
    }
    return props;
  };
}
var init_utilities2 = __esm({
  "node_modules/@shopify/admin-api-client/dist/graphql-client/dist/api-client-utilities/utilities.mjs"() {
  }
});

// node_modules/@shopify/admin-api-client/dist/constants.mjs
var DEFAULT_CONTENT_TYPE, DEFAULT_CLIENT_VERSION2, ACCESS_TOKEN_HEADER, CLIENT2, RETRIABLE_STATUS_CODES2, DEFAULT_RETRY_WAIT_TIME;
var init_constants2 = __esm({
  "node_modules/@shopify/admin-api-client/dist/constants.mjs"() {
    DEFAULT_CONTENT_TYPE = "application/json";
    DEFAULT_CLIENT_VERSION2 = "0.2.7";
    ACCESS_TOKEN_HEADER = "X-Shopify-Access-Token";
    CLIENT2 = "Admin API Client";
    RETRIABLE_STATUS_CODES2 = [429, 500, 503];
    DEFAULT_RETRY_WAIT_TIME = 1e3;
  }
});

// node_modules/@shopify/admin-api-client/dist/validations.mjs
function validateRequiredAccessToken(accessToken) {
  if (!accessToken) {
    throw new Error(`${CLIENT2}: an access token must be provided`);
  }
}
function validateServerSideUsage() {
  if (typeof window !== "undefined") {
    throw new Error(`${CLIENT2}: this client should not be used in the browser`);
  }
}
var init_validations2 = __esm({
  "node_modules/@shopify/admin-api-client/dist/validations.mjs"() {
    init_constants2();
  }
});

// node_modules/@shopify/admin-api-client/dist/graphql/client.mjs
function createAdminApiClient({ storeDomain, apiVersion, accessToken, userAgentPrefix, retries = 0, customFetchApi, logger }) {
  const currentSupportedApiVersions = getCurrentSupportedApiVersions();
  const storeUrl = validateDomainAndGetStoreUrl({
    client: CLIENT2,
    storeDomain
  });
  const baseApiVersionValidationParams = {
    client: CLIENT2,
    currentSupportedApiVersions,
    logger
  };
  validateServerSideUsage();
  validateApiVersion({
    client: CLIENT2,
    currentSupportedApiVersions,
    apiVersion,
    logger
  });
  validateRequiredAccessToken(accessToken);
  const apiUrlFormatter = generateApiUrlFormatter(storeUrl, apiVersion, baseApiVersionValidationParams);
  const config = {
    storeDomain: storeUrl,
    apiVersion,
    accessToken,
    headers: {
      "Content-Type": DEFAULT_CONTENT_TYPE,
      Accept: DEFAULT_CONTENT_TYPE,
      [ACCESS_TOKEN_HEADER]: accessToken,
      "User-Agent": `${userAgentPrefix ? `${userAgentPrefix} | ` : ""}${CLIENT2} v${DEFAULT_CLIENT_VERSION2}`
    },
    apiUrl: apiUrlFormatter(),
    userAgentPrefix
  };
  const graphqlClient = createGraphQLClient({
    headers: config.headers,
    url: config.apiUrl,
    retries,
    customFetchApi,
    logger
  });
  const getHeaders = generateGetHeaders(config);
  const getApiUrl = generateGetApiUrl(config, apiUrlFormatter);
  const getGQLClientParams = generateGetGQLClientParams({
    getHeaders,
    getApiUrl
  });
  const client = {
    config,
    getHeaders,
    getApiUrl,
    fetch: (...props) => {
      return graphqlClient.fetch(...getGQLClientParams(...props));
    },
    request: (...props) => {
      return graphqlClient.request(...getGQLClientParams(...props));
    }
  };
  return Object.freeze(client);
}
function generateApiUrlFormatter(storeUrl, defaultApiVersion, baseApiVersionValidationParams) {
  return (apiVersion) => {
    if (apiVersion) {
      validateApiVersion({
        ...baseApiVersionValidationParams,
        apiVersion
      });
    }
    const urlApiVersion = (apiVersion ?? defaultApiVersion).trim();
    return `${storeUrl}/admin/api/${urlApiVersion}/graphql.json`;
  };
}
function generateGetApiUrl(config, apiUrlFormatter) {
  return (propApiVersion) => {
    return propApiVersion ? apiUrlFormatter(propApiVersion) : config.apiUrl;
  };
}
var init_client = __esm({
  "node_modules/@shopify/admin-api-client/dist/graphql/client.mjs"() {
    init_graphql_client();
    init_validations();
    init_api_versions();
    init_utilities2();
    init_constants2();
    init_validations2();
  }
});

// node_modules/@shopify/admin-api-client/dist/rest/types.mjs
var Method;
var init_types = __esm({
  "node_modules/@shopify/admin-api-client/dist/rest/types.mjs"() {
    (function(Method2) {
      Method2["Get"] = "GET";
      Method2["Post"] = "POST";
      Method2["Put"] = "PUT";
      Method2["Delete"] = "DELETE";
    })(Method || (Method = {}));
  }
});

// node_modules/@shopify/admin-api-client/dist/rest/client.mjs
function createAdminRestApiClient({ storeDomain, apiVersion, accessToken, userAgentPrefix, logger, customFetchApi = fetch, retries: clientRetries = 0, scheme = "https", defaultRetryTime = DEFAULT_RETRY_WAIT_TIME, formatPaths = true }) {
  const currentSupportedApiVersions = getCurrentSupportedApiVersions();
  const storeUrl = validateDomainAndGetStoreUrl({
    client: CLIENT2,
    storeDomain
  }).replace("https://", `${scheme}://`);
  const baseApiVersionValidationParams = {
    client: CLIENT2,
    currentSupportedApiVersions,
    logger
  };
  validateServerSideUsage();
  validateApiVersion({
    client: CLIENT2,
    currentSupportedApiVersions,
    apiVersion,
    logger
  });
  validateRequiredAccessToken(accessToken);
  validateRetries({ client: CLIENT2, retries: clientRetries });
  const apiUrlFormatter = generateApiUrlFormatter2(storeUrl, apiVersion, baseApiVersionValidationParams, formatPaths);
  const clientLogger = generateClientLogger2(logger);
  const httpFetch = generateHttpFetch({
    customFetchApi,
    clientLogger,
    defaultRetryWaitTime: defaultRetryTime,
    client: CLIENT2,
    retriableCodes: RETRIABLE_STATUS_CODES2
  });
  const request = async (path, { method, data, headers: requestHeadersObj, searchParams, retries = 0, apiVersion: apiVersion2 }) => {
    validateRetries({ client: CLIENT2, retries });
    const url = apiUrlFormatter(path, searchParams ?? {}, apiVersion2);
    const requestHeaders = normalizedHeaders(requestHeadersObj ?? {});
    const userAgent = [
      ...requestHeaders["user-agent"] ? [requestHeaders["user-agent"]] : [],
      ...userAgentPrefix ? [userAgentPrefix] : [],
      `${CLIENT2} v${DEFAULT_CLIENT_VERSION2}`
    ].join(" | ");
    const headers = normalizedHeaders({
      "Content-Type": DEFAULT_CONTENT_TYPE,
      ...requestHeaders,
      Accept: DEFAULT_CONTENT_TYPE,
      [ACCESS_TOKEN_HEADER]: accessToken,
      "User-Agent": userAgent
    });
    const body = data && typeof data !== "string" ? JSON.stringify(data) : data;
    return httpFetch([url, { method, headers, ...body ? { body } : void 0 }], 1, retries ?? clientRetries);
  };
  return {
    get: (path, options) => request(path, { method: Method.Get, ...options }),
    put: (path, options) => request(path, { method: Method.Put, ...options }),
    post: (path, options) => request(path, { method: Method.Post, ...options }),
    delete: (path, options) => request(path, { method: Method.Delete, ...options })
  };
}
function generateApiUrlFormatter2(storeUrl, defaultApiVersion, baseApiVersionValidationParams, formatPaths = true) {
  return (path, searchParams, apiVersion) => {
    if (apiVersion) {
      validateApiVersion({
        ...baseApiVersionValidationParams,
        apiVersion
      });
    }
    function convertValue(params2, key, value) {
      if (Array.isArray(value)) {
        value.forEach((arrayValue) => convertValue(params2, `${key}[]`, arrayValue));
        return;
      } else if (typeof value === "object") {
        Object.entries(value).forEach(([objKey, objValue]) => convertValue(params2, `${key}[${objKey}]`, objValue));
        return;
      }
      params2.append(key, String(value));
    }
    const urlApiVersion = (apiVersion ?? defaultApiVersion).trim();
    let cleanPath = path.replace(/^\//, "");
    if (formatPaths) {
      if (!cleanPath.startsWith("admin")) {
        cleanPath = `admin/api/${urlApiVersion}/${cleanPath}`;
      }
      if (!cleanPath.endsWith(".json")) {
        cleanPath = `${cleanPath}.json`;
      }
    }
    const params = new URLSearchParams();
    if (searchParams) {
      for (const [key, value] of Object.entries(searchParams)) {
        convertValue(params, key, value);
      }
    }
    const queryString = params.toString() ? `?${params.toString()}` : "";
    return `${storeUrl}/${cleanPath}${queryString}`;
  };
}
function generateClientLogger2(logger) {
  return (logContent) => {
    if (logger) {
      logger(logContent);
    }
  };
}
function normalizedHeaders(headersObj) {
  const normalizedHeaders2 = {};
  for (const [key, value] of Object.entries(headersObj)) {
    normalizedHeaders2[key.toLowerCase()] = Array.isArray(value) ? value.join(", ") : String(value);
  }
  return normalizedHeaders2;
}
var init_client2 = __esm({
  "node_modules/@shopify/admin-api-client/dist/rest/client.mjs"() {
    init_http_fetch();
    init_utilities();
    init_validations();
    init_api_versions();
    init_validations2();
    init_constants2();
    init_types();
  }
});

// node_modules/@shopify/admin-api-client/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  createAdminApiClient: () => createAdminApiClient,
  createAdminRestApiClient: () => createAdminRestApiClient
});
var init_dist = __esm({
  "node_modules/@shopify/admin-api-client/dist/index.mjs"() {
    init_client();
    init_client2();
  }
});

// node_modules/@shopify/network/build/cjs/network.js
var require_network = __commonJS({
  "node_modules/@shopify/network/build/cjs/network.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Method = void 0;
    (function(Method2) {
      Method2["Get"] = "GET";
      Method2["Post"] = "POST";
      Method2["Put"] = "PUT";
      Method2["Patch"] = "PATCH";
      Method2["Delete"] = "DELETE";
      Method2["Head"] = "HEAD";
      Method2["Options"] = "OPTIONS";
      Method2["Connect"] = "CONNECT";
    })(exports.Method || (exports.Method = {}));
    exports.StatusCode = void 0;
    (function(StatusCode) {
      StatusCode[StatusCode["Continue"] = 100] = "Continue";
      StatusCode[StatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
      StatusCode[StatusCode["Ok"] = 200] = "Ok";
      StatusCode[StatusCode["Created"] = 201] = "Created";
      StatusCode[StatusCode["Accepted"] = 202] = "Accepted";
      StatusCode[StatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
      StatusCode[StatusCode["NoContent"] = 204] = "NoContent";
      StatusCode[StatusCode["ResetContent"] = 205] = "ResetContent";
      StatusCode[StatusCode["PartialContent"] = 206] = "PartialContent";
      StatusCode[StatusCode["MultipleChoices"] = 300] = "MultipleChoices";
      StatusCode[StatusCode["MovedPermanently"] = 301] = "MovedPermanently";
      StatusCode[StatusCode["Found"] = 302] = "Found";
      StatusCode[StatusCode["SeeOther"] = 303] = "SeeOther";
      StatusCode[StatusCode["NotModified"] = 304] = "NotModified";
      StatusCode[StatusCode["UseProxy"] = 305] = "UseProxy";
      StatusCode[StatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      StatusCode[StatusCode["BadRequest"] = 400] = "BadRequest";
      StatusCode[StatusCode["Unauthorized"] = 401] = "Unauthorized";
      StatusCode[StatusCode["PaymentRequired"] = 402] = "PaymentRequired";
      StatusCode[StatusCode["Forbidden"] = 403] = "Forbidden";
      StatusCode[StatusCode["NotFound"] = 404] = "NotFound";
      StatusCode[StatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      StatusCode[StatusCode["NotAcceptable"] = 406] = "NotAcceptable";
      StatusCode[StatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      StatusCode[StatusCode["RequestTimeout"] = 408] = "RequestTimeout";
      StatusCode[StatusCode["Conflict"] = 409] = "Conflict";
      StatusCode[StatusCode["Gone"] = 410] = "Gone";
      StatusCode[StatusCode["LengthRequired"] = 411] = "LengthRequired";
      StatusCode[StatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
      StatusCode[StatusCode["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
      StatusCode[StatusCode["RequestUriTooLong"] = 414] = "RequestUriTooLong";
      StatusCode[StatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
      StatusCode[StatusCode["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
      StatusCode[StatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
      StatusCode[StatusCode["ImATeapot"] = 418] = "ImATeapot";
      StatusCode[StatusCode["UnprocessableEntity"] = 422] = "UnprocessableEntity";
      StatusCode[StatusCode["TooManyRequests"] = 429] = "TooManyRequests";
      StatusCode[StatusCode["InternalServerError"] = 500] = "InternalServerError";
      StatusCode[StatusCode["NotImplemented"] = 501] = "NotImplemented";
      StatusCode[StatusCode["BadGateway"] = 502] = "BadGateway";
      StatusCode[StatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      StatusCode[StatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
      StatusCode[StatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
    })(exports.StatusCode || (exports.StatusCode = {}));
    exports.Header = void 0;
    (function(Header) {
      Header["Accept"] = "Accept";
      Header["AcceptEncoding"] = "Accept-Encoding";
      Header["AcceptLanguage"] = "Accept-Language";
      Header["AccessControlAllowCredentials"] = "Access-Control-Allow-Credentials";
      Header["AccessControlAllowHeaders"] = "Access-Control-Allow-Headers";
      Header["AccessControlAllowMethods"] = "Access-Control-Allow-Methods";
      Header["AccessControlAllowOrigin"] = "Access-Control-Allow-Origin";
      Header["AccessControlExposeHeaders"] = "Access-Control-Expose-Headers";
      Header["AccessControlMaxAge"] = "Access-Control-Max-Age";
      Header["AccessControlRequestHeaders"] = "Access-Control-Request-Headers";
      Header["AccessControlRequestMethod"] = "Access-Control-Request-Method";
      Header["Authorization"] = "Authorization";
      Header["CacheControl"] = "Cache-Control";
      Header["CacheStatus"] = "Cache-Status";
      Header["Connection"] = "Connection";
      Header["ContentDisposition"] = "Content-Disposition";
      Header["ContentEncoding"] = "Content-Encoding";
      Header["ContentLength"] = "Content-Length";
      Header["ContentSecurityPolicy"] = "Content-Security-Policy";
      Header["ContentSecurityPolicyReportOnly"] = "Content-Security-Policy-Report-Only";
      Header["ContentType"] = "Content-Type";
      Header["ContentTypeOptions"] = "X-Content-Type-Options";
      Header["Cookie"] = "Cookie";
      Header["DownloadOptions"] = "X-Download-Options";
      Header["ETag"] = "ETag";
      Header["Forwarded"] = "Forwarded";
      Header["ForwardedFor"] = "X-Forwarded-For";
      Header["ForwardedHost"] = "X-Forwarded-Host";
      Header["ForwardedProtocol"] = "X-Forwarded-Proto";
      Header["FrameOptions"] = "X-Frame-Options";
      Header["Host"] = "Host";
      Header["IfNoneMatch"] = "If-None-Match";
      Header["Location"] = "Location";
      Header["Origin"] = "Origin";
      Header["ReferrerPolicy"] = "Referrer-Policy";
      Header["ServerTiming"] = "Server-Timing";
      Header["StrictTransportSecurity"] = "Strict-Transport-Security";
      Header["TimingAllowOrigin"] = "Timing-Allow-Origin";
      Header["Trailer"] = "Trailer";
      Header["TransferEncoding"] = "Transfer-Encoding";
      Header["UserAgent"] = "User-Agent";
      Header["WwwAuthenticate"] = "WWW-Authenticate";
      Header["XhrRedirectedTo"] = "X-XHR-Redirected-To";
      Header["XhrReferer"] = "X-XHR-Referer";
      Header["XssProtecton"] = "X-XSS-Protection";
      Header["XContentTypeOptions"] = "X-Content-Type-Options";
      Header["XDownloadOptions"] = "X-Download-Options";
      Header["XForwardedFor"] = "X-Forwarded-For";
      Header["XForwardedHost"] = "X-Forwarded-Host";
      Header["XForwardedProto"] = "X-Forwarded-Proto";
      Header["XFrameOptions"] = "X-Frame-Options";
      Header["XXhrRedirectedTo"] = "X-XHR-Redirected-To";
      Header["XXhrReferer"] = "X-XHR-Referer";
      Header["XXssProtecton"] = "X-XSS-Protection";
      Header["XXssProtection"] = "X-XSS-Protection";
    })(exports.Header || (exports.Header = {}));
    exports.CspDirective = void 0;
    (function(CspDirective) {
      CspDirective["ChildSrc"] = "child-src";
      CspDirective["ConnectSrc"] = "connect-src";
      CspDirective["DefaultSrc"] = "default-src";
      CspDirective["FontSrc"] = "font-src";
      CspDirective["FrameSrc"] = "frame-src";
      CspDirective["ImgSrc"] = "img-src";
      CspDirective["ManifestSrc"] = "manifest-src";
      CspDirective["MediaSrc"] = "media-src";
      CspDirective["ObjectSrc"] = "object-src";
      CspDirective["PrefetchSrc"] = "prefetch-src";
      CspDirective["ScriptSrc"] = "script-src";
      CspDirective["StyleSrc"] = "style-src";
      CspDirective["WebrtcSrc"] = "webrtc-src";
      CspDirective["WorkerSrc"] = "worker-src";
      CspDirective["BaseUri"] = "base-uri";
      CspDirective["PluginTypes"] = "plugin-types";
      CspDirective["Sandbox"] = "sandbox";
      CspDirective["FormAction"] = "form-action";
      CspDirective["FrameAncestors"] = "frame-ancestors";
      CspDirective["ReportUri"] = "report-uri";
      CspDirective["BlockAllMixedContent"] = "block-all-mixed-content";
      CspDirective["RequireSriFor"] = "require-sri-for";
      CspDirective["UpgradeInsecureRequests"] = "upgrade-insecure-requests";
    })(exports.CspDirective || (exports.CspDirective = {}));
    exports.CspSandboxAllow = void 0;
    (function(CspSandboxAllow) {
      CspSandboxAllow["Forms"] = "allow-forms";
      CspSandboxAllow["SameOrigin"] = "allow-same-origin";
      CspSandboxAllow["Scripts"] = "allow-scripts";
      CspSandboxAllow["Popups"] = "allow-popups";
      CspSandboxAllow["Modals"] = "allow-modals";
      CspSandboxAllow["OrientationLock"] = "allow-orientation-lock";
      CspSandboxAllow["PointerLock"] = "allow-pointer-lock";
      CspSandboxAllow["Presentation"] = "allow-presentation";
      CspSandboxAllow["PopupsToEscapeSandbox"] = "allow-popups-to-escape-sandbox";
      CspSandboxAllow["TopNavigation"] = "allow-top-navigation";
    })(exports.CspSandboxAllow || (exports.CspSandboxAllow = {}));
    exports.SpecialSource = void 0;
    (function(SpecialSource) {
      SpecialSource["Any"] = "*";
      SpecialSource["Self"] = "'self'";
      SpecialSource["UnsafeInline"] = "'unsafe-inline'";
      SpecialSource["UnsafeEval"] = "'unsafe-eval'";
      SpecialSource["None"] = "'none'";
      SpecialSource["StrictDynamic"] = "'strict-dynamic'";
      SpecialSource["ReportSample"] = "'report-sample'";
      SpecialSource["Data"] = "data:";
      SpecialSource["Blob"] = "blob:";
      SpecialSource["FileSystem"] = "filesystem:";
    })(exports.SpecialSource || (exports.SpecialSource = {}));
    exports.SriAsset = void 0;
    (function(SriAsset) {
      SriAsset["Script"] = "script";
      SriAsset["Style"] = "style";
    })(exports.SriAsset || (exports.SriAsset = {}));
    exports.HashAlgorithm = void 0;
    (function(HashAlgorithm) {
      HashAlgorithm["Sha256"] = "sha256";
      HashAlgorithm["Sha384"] = "sha384";
      HashAlgorithm["Sha512"] = "sha512";
    })(exports.HashAlgorithm || (exports.HashAlgorithm = {}));
    exports.ResponseType = void 0;
    (function(ResponseType) {
      ResponseType["Informational"] = "1xx";
      ResponseType["Success"] = "2xx";
      ResponseType["Redirection"] = "3xx";
      ResponseType["ClientError"] = "4xx";
      ResponseType["ServerError"] = "5xx";
      ResponseType["Unknown"] = "Unknown";
    })(exports.ResponseType || (exports.ResponseType = {}));
    function getResponseType(status) {
      if (status >= 100 && status < 200) {
        return exports.ResponseType.Informational;
      } else if (status >= 200 && status < 300) {
        return exports.ResponseType.Success;
      } else if (status >= 300 && status < 400) {
        return exports.ResponseType.Redirection;
      } else if (status >= 400 && status < 500) {
        return exports.ResponseType.ClientError;
      } else if (status >= 500 && status < 600) {
        return exports.ResponseType.ServerError;
      } else {
        return exports.ResponseType.Unknown;
      }
    }
    function nonceSource(nonce) {
      return `'nonce-${nonce}'`;
    }
    function hashSource(hashAlgorithm, value) {
      return `'${hashAlgorithm}-${value}'`;
    }
    exports.CacheControl = void 0;
    (function(CacheControl) {
      CacheControl["NoCache"] = "no-cache";
      CacheControl["NoStore"] = "no-store";
      CacheControl["MustRevalidate"] = "must-revalidate";
      CacheControl["MaxAge"] = "max-age";
    })(exports.CacheControl || (exports.CacheControl = {}));
    var noCache = `${exports.CacheControl.NoCache},${exports.CacheControl.NoStore},${exports.CacheControl.MustRevalidate},${exports.CacheControl.MaxAge}=0`;
    exports.getResponseType = getResponseType;
    exports.hashSource = hashSource;
    exports.noCache = noCache;
    exports.nonceSource = nonceSource;
  }
});

// node_modules/@shopify/network/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@shopify/network/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var network = require_network();
    Object.defineProperty(exports, "CacheControl", {
      enumerable: true,
      get: function() {
        return network.CacheControl;
      }
    });
    Object.defineProperty(exports, "CspDirective", {
      enumerable: true,
      get: function() {
        return network.CspDirective;
      }
    });
    Object.defineProperty(exports, "CspSandboxAllow", {
      enumerable: true,
      get: function() {
        return network.CspSandboxAllow;
      }
    });
    Object.defineProperty(exports, "HashAlgorithm", {
      enumerable: true,
      get: function() {
        return network.HashAlgorithm;
      }
    });
    Object.defineProperty(exports, "Header", {
      enumerable: true,
      get: function() {
        return network.Header;
      }
    });
    Object.defineProperty(exports, "Method", {
      enumerable: true,
      get: function() {
        return network.Method;
      }
    });
    Object.defineProperty(exports, "ResponseType", {
      enumerable: true,
      get: function() {
        return network.ResponseType;
      }
    });
    Object.defineProperty(exports, "SpecialSource", {
      enumerable: true,
      get: function() {
        return network.SpecialSource;
      }
    });
    Object.defineProperty(exports, "SriAsset", {
      enumerable: true,
      get: function() {
        return network.SriAsset;
      }
    });
    Object.defineProperty(exports, "StatusCode", {
      enumerable: true,
      get: function() {
        return network.StatusCode;
      }
    });
    exports.getResponseType = network.getResponseType;
    exports.hashSource = network.hashSource;
    exports.noCache = network.noCache;
    exports.nonceSource = network.nonceSource;
  }
});

// node_modules/@shopify/network/index.js
var require_network2 = __commonJS({
  "node_modules/@shopify/network/index.js"(exports, module) {
    module.exports = require_cjs();
  }
});

// node_modules/@shopify/shopify-api/lib/clients/common.js
var require_common = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throwFailedRequest = exports.clientLoggerFactory = exports.getUserAgent = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var network_1 = require_network2();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var types_1 = require_types();
    var version_1 = require_version();
    var runtime_1 = require_runtime();
    var logger_1 = require_logger();
    function getUserAgent(config) {
      let userAgentPrefix = `${types_1.LIBRARY_NAME} v${version_1.SHOPIFY_API_LIBRARY_VERSION} | ${(0, runtime_1.abstractRuntimeString)()}`;
      if (config.userAgentPrefix) {
        userAgentPrefix = `${config.userAgentPrefix} | ${userAgentPrefix}`;
      }
      return userAgentPrefix;
    }
    exports.getUserAgent = getUserAgent;
    function clientLoggerFactory(config) {
      return (logContent) => {
        if (config.logger.httpRequests) {
          switch (logContent.type) {
            case "HTTP-Response": {
              const responseLog = logContent.content;
              (0, logger_1.logger)(config).debug("Received response for HTTP request", {
                requestParams: JSON.stringify(responseLog.requestParams),
                response: JSON.stringify(responseLog.response)
              });
              break;
            }
            case "HTTP-Retry": {
              const responseLog = logContent.content;
              (0, logger_1.logger)(config).debug("Retrying HTTP request", {
                requestParams: JSON.stringify(responseLog.requestParams),
                retryAttempt: responseLog.retryAttempt,
                maxRetries: responseLog.maxRetries,
                response: JSON.stringify(responseLog.lastResponse)
              });
              break;
            }
            default: {
              (0, logger_1.logger)(config).debug(`HTTP request event: ${logContent.content}`);
              break;
            }
          }
        }
      };
    }
    exports.clientLoggerFactory = clientLoggerFactory;
    function throwFailedRequest(body, response, atMaxRetries) {
      var _a, _b, _c;
      const responseHeaders = (0, runtime_1.canonicalizeHeaders)(Object.fromEntries((_a = response.headers.entries()) !== null && _a !== void 0 ? _a : []));
      if (response.status === network_1.StatusCode.Ok && body.errors.graphQLErrors) {
        throw new ShopifyErrors.GraphqlQueryError({
          message: (_c = (_b = body.errors.graphQLErrors) === null || _b === void 0 ? void 0 : _b[0].message) !== null && _c !== void 0 ? _c : "GraphQL operation failed",
          response,
          headers: responseHeaders,
          body
        });
      }
      const errorMessages = [];
      if (body.errors) {
        errorMessages.push(JSON.stringify(body.errors, null, 2));
      }
      const xRequestId = (0, runtime_1.getHeader)(responseHeaders, "x-request-id");
      if (xRequestId) {
        errorMessages.push(`If you report this error, please include this id: ${xRequestId}`);
      }
      const errorMessage = errorMessages.length ? `:
${errorMessages.join("\n")}` : "";
      const code = response.status;
      const statusText = response.statusText;
      switch (true) {
        case response.status === network_1.StatusCode.TooManyRequests: {
          if (atMaxRetries) {
            throw new ShopifyErrors.HttpMaxRetriesError("Attempted the maximum number of retries for HTTP request.");
          } else {
            const retryAfter = (0, runtime_1.getHeader)(responseHeaders, "Retry-After");
            throw new ShopifyErrors.HttpThrottlingError({
              message: `Shopify is throttling requests ${errorMessage}`,
              code,
              statusText,
              body,
              headers: responseHeaders,
              retryAfter: retryAfter ? parseFloat(retryAfter) : void 0
            });
          }
        }
        case response.status >= network_1.StatusCode.InternalServerError:
          if (atMaxRetries) {
            throw new ShopifyErrors.HttpMaxRetriesError("Attempted the maximum number of retries for HTTP request.");
          } else {
            throw new ShopifyErrors.HttpInternalError({
              message: `Shopify internal error${errorMessage}`,
              code,
              statusText,
              body,
              headers: responseHeaders
            });
          }
        default:
          throw new ShopifyErrors.HttpResponseError({
            message: `Received an error response (${response.status} ${response.statusText}) from Shopify${errorMessage}`,
            code,
            statusText,
            body,
            headers: responseHeaders
          });
      }
    }
    exports.throwFailedRequest = throwFailedRequest;
  }
});

// node_modules/@shopify/shopify-api/lib/clients/admin/graphql/client.js
var require_client = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/admin/graphql/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.graphqlClientClass = exports.GraphqlClient = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var admin_api_client_1 = (init_dist(), __toCommonJS(dist_exports));
    var logger_1 = require_logger();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var runtime_1 = require_runtime();
    var common_1 = require_common();
    var GraphqlClient = class {
      constructor(params) {
        var _a, _b;
        const config = this.graphqlClass().config;
        if (!config.isCustomStoreApp && !params.session.accessToken) {
          throw new ShopifyErrors.MissingRequiredArgument("Missing access token when creating GraphQL client");
        }
        if (params.apiVersion) {
          const message = params.apiVersion === config.apiVersion ? `Admin client has a redundant API version override to the default ${params.apiVersion}` : `Admin client overriding default API version ${config.apiVersion} with ${params.apiVersion}`;
          (0, logger_1.logger)(config).debug(message);
        }
        this.session = params.session;
        this.apiVersion = params.apiVersion;
        this.client = (0, admin_api_client_1.createAdminApiClient)({
          accessToken: (_a = config.adminApiAccessToken) !== null && _a !== void 0 ? _a : this.session.accessToken,
          apiVersion: (_b = this.apiVersion) !== null && _b !== void 0 ? _b : config.apiVersion,
          storeDomain: this.session.shop,
          customFetchApi: runtime_1.abstractFetch,
          logger: (0, common_1.clientLoggerFactory)(config),
          userAgentPrefix: (0, common_1.getUserAgent)(config)
        });
      }
      query(params) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          (0, logger_1.logger)(this.graphqlClass().config).deprecated("10.0.0", "The query method is deprecated, and was replaced with the request method.\nSee the migration guide: https://github.com/Shopify/shopify-api-js/blob/main/packages/shopify-api/docs/migrating-to-v9.md#using-the-new-clients.");
          if (typeof params.data === "string" && params.data.length === 0 || Object.entries(params.data).length === 0) {
            throw new ShopifyErrors.MissingRequiredArgument("Query missing.");
          }
          let operation;
          let variables;
          if (typeof params.data === "string") {
            operation = params.data;
          } else {
            operation = params.data.query;
            variables = params.data.variables;
          }
          const headers = Object.fromEntries(Object.entries((_a = params === null || params === void 0 ? void 0 : params.extraHeaders) !== null && _a !== void 0 ? _a : {}).map(([key, value]) => [
            key,
            Array.isArray(value) ? value.join(", ") : value.toString()
          ]));
          const response = yield this.request(operation, {
            headers,
            retries: params.tries ? params.tries - 1 : void 0,
            variables
          });
          return { body: response, headers: {} };
        });
      }
      request(operation, options) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const response = yield this.client.request(operation, Object.assign({ apiVersion: this.apiVersion || this.graphqlClass().config.apiVersion }, options));
          if (response.errors) {
            const fetchResponse = response.errors.response;
            (0, common_1.throwFailedRequest)(response, fetchResponse, ((_a = options === null || options === void 0 ? void 0 : options.retries) !== null && _a !== void 0 ? _a : 0) > 0);
          }
          return response;
        });
      }
      graphqlClass() {
        return this.constructor;
      }
    };
    exports.GraphqlClient = GraphqlClient;
    function graphqlClientClass({ config }) {
      class NewGraphqlClient extends GraphqlClient {
      }
      NewGraphqlClient.config = config;
      Reflect.defineProperty(NewGraphqlClient, "name", {
        value: "GraphqlClient"
      });
      return NewGraphqlClient;
    }
    exports.graphqlClientClass = graphqlClientClass;
  }
});

// node_modules/@shopify/shopify-api/lib/clients/types.js
var require_types4 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphqlClient = exports.DataType = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_types2(), exports);
    tslib_1.__exportStar(require_types3(), exports);
    var DataType;
    (function(DataType2) {
      DataType2["JSON"] = "application/json";
      DataType2["GraphQL"] = "application/graphql";
      DataType2["URLEncoded"] = "application/x-www-form-urlencoded";
    })(DataType || (exports.DataType = DataType = {}));
    var client_1 = require_client();
    Object.defineProperty(exports, "GraphqlClient", { enumerable: true, get: function() {
      return client_1.GraphqlClient;
    } });
  }
});

export {
  require_types,
  require_version,
  require_logger,
  dist_exports,
  init_dist,
  require_network2 as require_network,
  require_common,
  require_client,
  require_types4 as require_types2
};
//# sourceMappingURL=chunk-7DNGBRSA.js.map
