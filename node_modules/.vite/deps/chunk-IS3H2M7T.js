import {
  dist_exports,
  init_dist,
  require_client,
  require_common,
  require_logger,
  require_network,
  require_types as require_types2,
  require_types2 as require_types3,
  require_version
} from "./chunk-7DNGBRSA.js";
import {
  init_tslib_es6,
  require_crypto,
  require_error,
  require_http,
  require_platform,
  require_runtime,
  require_types,
  tslib_es6_exports
} from "./chunk-QFE7ZBXI.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-WXXH56N5.js";

// node_modules/@shopify/shopify-api/rest/load-rest-resources.js
var require_load_rest_resources = __commonJS({
  "node_modules/@shopify/shopify-api/rest/load-rest-resources.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadRestResources = void 0;
    var logger_1 = require_logger();
    function loadRestResources({ resources, config, RestClient }) {
      const firstResource = Object.keys(resources)[0];
      if (config.apiVersion !== resources[firstResource].apiVersion) {
        (0, logger_1.logger)(config).warning(`Loading REST resources for API version ${resources[firstResource].apiVersion}, which doesn't match the default ${config.apiVersion}`);
      }
      return Object.fromEntries(Object.entries(resources).map(([name, resource]) => {
        class NewResource extends resource {
        }
        NewResource.setClassProperties({
          Client: RestClient,
          config
        });
        Object.entries(NewResource.hasOne).map(([_attribute, klass]) => {
          klass.setClassProperties({
            Client: RestClient,
            config
          });
        });
        Object.entries(NewResource.hasMany).map(([_attribute, klass]) => {
          klass.setClassProperties({
            Client: RestClient,
            config
          });
        });
        Reflect.defineProperty(NewResource, "name", {
          value: name
        });
        return [name, NewResource];
      }));
    }
    exports.loadRestResources = loadRestResources;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/scopes/index.js
var require_scopes = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/scopes/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthScopes = void 0;
    var AuthScopes = class _AuthScopes {
      constructor(scopes) {
        let scopesArray = [];
        if (typeof scopes === "string") {
          scopesArray = scopes.split(new RegExp(`${_AuthScopes.SCOPE_DELIMITER}\\s*`));
        } else if (Array.isArray(scopes)) {
          scopesArray = scopes;
        } else if (scopes) {
          scopesArray = Array.from(scopes.expandedScopes);
        }
        scopesArray = scopesArray.map((scope) => scope.trim()).filter((scope) => scope.length);
        const impliedScopes = this.getImpliedScopes(scopesArray);
        const scopeSet = new Set(scopesArray);
        const impliedSet = new Set(impliedScopes);
        this.compressedScopes = new Set([...scopeSet].filter((x) => !impliedSet.has(x)));
        this.expandedScopes = /* @__PURE__ */ new Set([...scopeSet, ...impliedSet]);
      }
      /**
       * Checks whether the current set of scopes includes the given one.
       */
      has(scope) {
        let other;
        if (scope instanceof _AuthScopes) {
          other = scope;
        } else {
          other = new _AuthScopes(scope);
        }
        return other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0;
      }
      /**
       * Checks whether the current set of scopes equals the given one.
       */
      equals(otherScopes) {
        let other;
        if (otherScopes instanceof _AuthScopes) {
          other = otherScopes;
        } else {
          other = new _AuthScopes(otherScopes);
        }
        return this.compressedScopes.size === other.compressedScopes.size && this.toArray().filter((x) => !other.has(x)).length === 0;
      }
      /**
       * Returns a comma-separated string with the current set of scopes.
       */
      toString() {
        return this.toArray().join(_AuthScopes.SCOPE_DELIMITER);
      }
      /**
       * Returns an array with the current set of scopes.
       */
      toArray() {
        return [...this.compressedScopes];
      }
      getImpliedScopes(scopesArray) {
        return scopesArray.reduce((array, current) => {
          const matches = current.match(/^(unauthenticated_)?write_(.*)$/);
          if (matches) {
            array.push(`${matches[1] ? matches[1] : ""}read_${matches[2]}`);
          }
          return array;
        }, []);
      }
    };
    exports.AuthScopes = AuthScopes;
    AuthScopes.SCOPE_DELIMITER = ",";
  }
});

// node_modules/@shopify/shopify-api/lib/config.js
var require_config = __commonJS({
  "node_modules/@shopify/shopify-api/lib/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateConfig = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var error_1 = require_error();
    var types_1 = require_types2();
    var scopes_1 = require_scopes();
    var logger_1 = require_logger();
    function validateConfig(params) {
      var _a2;
      const config = {
        apiKey: "",
        apiSecretKey: "",
        scopes: new scopes_1.AuthScopes([]),
        hostName: "",
        hostScheme: "https",
        apiVersion: types_1.LATEST_API_VERSION,
        isEmbeddedApp: true,
        isCustomStoreApp: false,
        logger: {
          log: defaultLogFunction,
          level: types_1.LogSeverity.Info,
          httpRequests: false,
          timestamps: false
        },
        future: {}
      };
      const mandatory = ["apiSecretKey", "hostName"];
      if (!("isCustomStoreApp" in params) || !params.isCustomStoreApp) {
        mandatory.push("apiKey");
        mandatory.push("scopes");
      }
      if ("isCustomStoreApp" in params && params.isCustomStoreApp) {
        if (!("adminApiAccessToken" in params) || ((_a2 = params.adminApiAccessToken) === null || _a2 === void 0 ? void 0 : _a2.length) === 0) {
          mandatory.push("adminApiAccessToken");
        }
      }
      const missing = [];
      mandatory.forEach((key) => {
        if (!notEmpty(params[key])) {
          missing.push(key);
        }
      });
      if (missing.length) {
        throw new error_1.ShopifyError(`Cannot initialize Shopify API Library. Missing values for: ${missing.join(", ")}`);
      }
      const { hostScheme, isCustomStoreApp, adminApiAccessToken, userAgentPrefix, logger, privateAppStorefrontAccessToken, customShopDomains, billing } = params, mandatoryParams = tslib_1.__rest(params, ["hostScheme", "isCustomStoreApp", "adminApiAccessToken", "userAgentPrefix", "logger", "privateAppStorefrontAccessToken", "customShopDomains", "billing"]);
      Object.assign(config, mandatoryParams, {
        hostName: params.hostName.replace(/\/$/, ""),
        scopes: params.scopes instanceof scopes_1.AuthScopes ? params.scopes : new scopes_1.AuthScopes(params.scopes),
        hostScheme: hostScheme !== null && hostScheme !== void 0 ? hostScheme : config.hostScheme,
        isCustomStoreApp: isCustomStoreApp !== null && isCustomStoreApp !== void 0 ? isCustomStoreApp : config.isCustomStoreApp,
        adminApiAccessToken: adminApiAccessToken !== null && adminApiAccessToken !== void 0 ? adminApiAccessToken : config.adminApiAccessToken,
        userAgentPrefix: userAgentPrefix !== null && userAgentPrefix !== void 0 ? userAgentPrefix : config.userAgentPrefix,
        logger: Object.assign(Object.assign({}, config.logger), logger || {}),
        privateAppStorefrontAccessToken: privateAppStorefrontAccessToken !== null && privateAppStorefrontAccessToken !== void 0 ? privateAppStorefrontAccessToken : config.privateAppStorefrontAccessToken,
        customShopDomains: customShopDomains !== null && customShopDomains !== void 0 ? customShopDomains : config.customShopDomains,
        billing: billing !== null && billing !== void 0 ? billing : config.billing
      });
      if (config.isCustomStoreApp && params.adminApiAccessToken === params.apiSecretKey) {
        (0, logger_1.logger)(config).warning("adminApiAccessToken is set to the same value as apiSecretKey. adminApiAccessToken should be set to the Admin API access token for custom store apps; apiSecretKey should be set to the custom store app's API secret key.");
      }
      return config;
    }
    exports.validateConfig = validateConfig;
    function notEmpty(value) {
      if (value == null) {
        return false;
      }
      return typeof value === "string" || Array.isArray(value) ? value.length > 0 : true;
    }
    function defaultLogFunction(severity, message2) {
      switch (severity) {
        case types_1.LogSeverity.Debug:
          console.debug(message2);
          break;
        case types_1.LogSeverity.Info:
          console.log(message2);
          break;
        case types_1.LogSeverity.Warning:
          console.warn(message2);
          break;
        case types_1.LogSeverity.Error:
          console.error(message2);
          break;
      }
    }
  }
});

// node_modules/@shopify/shopify-api/lib/clients/admin/rest/client.js
var require_client2 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/admin/rest/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.restClientClass = exports.RestClient = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var admin_api_client_1 = (init_dist(), __toCommonJS(dist_exports));
    var network_1 = require_network();
    var common_1 = require_common();
    var runtime_1 = require_runtime();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var logger_1 = require_logger();
    var RestClient = class _RestClient {
      constructor({ session, apiVersion }) {
        var _a2;
        this.loggedDeprecations = {};
        const config = this.restClass().config;
        if (!config.isCustomStoreApp && !session.accessToken) {
          throw new ShopifyErrors.MissingRequiredArgument("Missing access token when creating REST client");
        }
        if (apiVersion) {
          const message2 = apiVersion === config.apiVersion ? `REST client has a redundant API version override to the default ${apiVersion}` : `REST client overriding default API version ${config.apiVersion} with ${apiVersion}`;
          (0, logger_1.logger)(config).debug(message2);
        }
        const customStoreAppAccessToken = (_a2 = config.adminApiAccessToken) !== null && _a2 !== void 0 ? _a2 : config.apiSecretKey;
        this.session = session;
        this.apiVersion = apiVersion !== null && apiVersion !== void 0 ? apiVersion : config.apiVersion;
        this.client = (0, admin_api_client_1.createAdminRestApiClient)({
          scheme: config.hostScheme,
          storeDomain: session.shop,
          apiVersion: apiVersion !== null && apiVersion !== void 0 ? apiVersion : config.apiVersion,
          accessToken: config.isCustomStoreApp ? customStoreAppAccessToken : session.accessToken,
          customFetchApi: runtime_1.abstractFetch,
          logger: (0, common_1.clientLoggerFactory)(config),
          userAgentPrefix: (0, common_1.getUserAgent)(config),
          defaultRetryTime: this.restClass().RETRY_WAIT_TIME,
          formatPaths: this.restClass().formatPaths
        });
      }
      /**
       * Performs a GET request on the given path.
       */
      get(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return this.request(Object.assign({ method: network_1.Method.Get }, params));
        });
      }
      /**
       * Performs a POST request on the given path.
       */
      post(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return this.request(Object.assign({ method: network_1.Method.Post }, params));
        });
      }
      /**
       * Performs a PUT request on the given path.
       */
      put(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return this.request(Object.assign({ method: network_1.Method.Put }, params));
        });
      }
      /**
       * Performs a DELETE request on the given path.
       */
      delete(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return this.request(Object.assign({ method: network_1.Method.Delete }, params));
        });
      }
      request(params) {
        var _a2, _b2, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const requestParams = {
            headers: Object.assign(Object.assign({}, params.extraHeaders), params.type ? { "Content-Type": params.type.toString() } : {}),
            retries: params.tries ? params.tries - 1 : void 0,
            searchParams: params.query
          };
          let response;
          switch (params.method) {
            case network_1.Method.Get:
              response = yield this.client.get(params.path, requestParams);
              break;
            case network_1.Method.Put:
              response = yield this.client.put(params.path, Object.assign(Object.assign({}, requestParams), { data: params.data }));
              break;
            case network_1.Method.Post:
              response = yield this.client.post(params.path, Object.assign(Object.assign({}, requestParams), { data: params.data }));
              break;
            case network_1.Method.Delete:
              response = yield this.client.delete(params.path, requestParams);
              break;
            default:
              throw new ShopifyErrors.InvalidRequestError(`Unsupported request method '${params.method}'`);
          }
          const body = yield response.json();
          const responseHeaders = (0, runtime_1.canonicalizeHeaders)(Object.fromEntries(response.headers.entries()));
          if (!response.ok) {
            (0, common_1.throwFailedRequest)(body, response, ((_a2 = params.tries) !== null && _a2 !== void 0 ? _a2 : 1) > 1);
          }
          const requestReturn = {
            body,
            headers: responseHeaders
          };
          yield this.logDeprecations({
            method: params.method,
            url: params.path,
            headers: requestParams.headers,
            body: params.data ? JSON.stringify(params.data) : void 0
          }, requestReturn);
          const link = response.headers.get("Link");
          if (link !== void 0) {
            const pageInfo = {
              limit: ((_b2 = params.query) === null || _b2 === void 0 ? void 0 : _b2.limit) ? (_c = params.query) === null || _c === void 0 ? void 0 : _c.limit.toString() : _RestClient.DEFAULT_LIMIT
            };
            if (link) {
              const links = link.split(", ");
              for (const link2 of links) {
                const parsedLink = link2.match(_RestClient.LINK_HEADER_REGEXP);
                if (!parsedLink) {
                  continue;
                }
                const linkRel = parsedLink[2];
                const linkUrl = new URL(parsedLink[1]);
                const linkFields = linkUrl.searchParams.get("fields");
                const linkPageToken = linkUrl.searchParams.get("page_info");
                if (!pageInfo.fields && linkFields) {
                  pageInfo.fields = linkFields.split(",");
                }
                if (linkPageToken) {
                  switch (linkRel) {
                    case "previous":
                      pageInfo.previousPageUrl = parsedLink[1];
                      pageInfo.prevPage = this.buildRequestParams(parsedLink[1]);
                      break;
                    case "next":
                      pageInfo.nextPageUrl = parsedLink[1];
                      pageInfo.nextPage = this.buildRequestParams(parsedLink[1]);
                      break;
                  }
                }
              }
            }
            requestReturn.pageInfo = pageInfo;
          }
          return requestReturn;
        });
      }
      restClass() {
        return this.constructor;
      }
      buildRequestParams(newPageUrl) {
        const pattern = `^/admin/api/[^/]+/(.*).json$`;
        const url = new URL(newPageUrl);
        const path = url.pathname.replace(new RegExp(pattern), "$1");
        return {
          path,
          query: Object.fromEntries(url.searchParams.entries())
        };
      }
      logDeprecations(request, response) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const config = this.restClass().config;
          const deprecationReason = (0, runtime_1.getHeader)(response.headers, "X-Shopify-API-Deprecated-Reason");
          if (deprecationReason) {
            const deprecation = {
              message: deprecationReason,
              path: request.url
            };
            if (request.body) {
              deprecation.body = `${request.body.substring(0, 100)}...`;
            }
            const depHash = yield (0, runtime_1.createSHA256HMAC)(config.apiSecretKey, JSON.stringify(deprecation), runtime_1.HashFormat.Hex);
            if (!Object.keys(this.loggedDeprecations).includes(depHash) || Date.now() - this.loggedDeprecations[depHash] >= _RestClient.DEPRECATION_ALERT_DELAY) {
              this.loggedDeprecations[depHash] = Date.now();
              const stack = new Error().stack;
              const message2 = `API Deprecation Notice ${(/* @__PURE__ */ new Date()).toLocaleString()} : ${JSON.stringify(deprecation)}  -  Stack Trace: ${stack}`;
              yield (0, logger_1.logger)(config).warning(message2);
            }
          }
        });
      }
    };
    exports.RestClient = RestClient;
    RestClient.LINK_HEADER_REGEXP = /<([^<]+)>; rel="([^"]+)"/;
    RestClient.DEFAULT_LIMIT = "50";
    RestClient.RETRY_WAIT_TIME = 1e3;
    RestClient.DEPRECATION_ALERT_DELAY = 3e5;
    function restClientClass(params) {
      const { config, formatPaths } = params;
      class NewRestClient extends RestClient {
      }
      NewRestClient.config = config;
      NewRestClient.formatPaths = formatPaths === void 0 ? true : formatPaths;
      Reflect.defineProperty(NewRestClient, "name", {
        value: "RestClient"
      });
      return NewRestClient;
    }
    exports.restClientClass = restClientClass;
  }
});

// node_modules/@shopify/shopify-api/lib/clients/admin/index.js
var require_admin = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/admin/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RestClient = exports.restClientClass = exports.GraphqlClient = exports.graphqlClientClass = void 0;
    var client_1 = require_client();
    Object.defineProperty(exports, "graphqlClientClass", { enumerable: true, get: function() {
      return client_1.graphqlClientClass;
    } });
    Object.defineProperty(exports, "GraphqlClient", { enumerable: true, get: function() {
      return client_1.GraphqlClient;
    } });
    var client_2 = require_client2();
    Object.defineProperty(exports, "restClientClass", { enumerable: true, get: function() {
      return client_2.restClientClass;
    } });
    Object.defineProperty(exports, "RestClient", { enumerable: true, get: function() {
      return client_2.RestClient;
    } });
  }
});

// node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/graphql-client/constants.mjs
var CLIENT, MIN_RETRIES, MAX_RETRIES, GQL_API_ERROR, UNEXPECTED_CONTENT_TYPE_ERROR, NO_DATA_OR_ERRORS_ERROR, CONTENT_TYPES, SDK_VARIANT_HEADER, SDK_VERSION_HEADER, DEFAULT_SDK_VARIANT, DEFAULT_CLIENT_VERSION, RETRY_WAIT_TIME, RETRIABLE_STATUS_CODES, DEFER_OPERATION_REGEX, NEWLINE_SEPARATOR, BOUNDARY_HEADER_REGEX, HEADER_SEPARATOR;
var init_constants = __esm({
  "node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/graphql-client/constants.mjs"() {
    CLIENT = "GraphQL Client";
    MIN_RETRIES = 0;
    MAX_RETRIES = 3;
    GQL_API_ERROR = "An error occurred while fetching from the API. Review 'graphQLErrors' for details.";
    UNEXPECTED_CONTENT_TYPE_ERROR = "Response returned unexpected Content-Type:";
    NO_DATA_OR_ERRORS_ERROR = "An unknown error has occurred. The API did not return a data object or any errors in its response.";
    CONTENT_TYPES = {
      json: "application/json",
      multipart: "multipart/mixed"
    };
    SDK_VARIANT_HEADER = "X-SDK-Variant";
    SDK_VERSION_HEADER = "X-SDK-Version";
    DEFAULT_SDK_VARIANT = "shopify-graphql-client";
    DEFAULT_CLIENT_VERSION = "0.10.2";
    RETRY_WAIT_TIME = 1e3;
    RETRIABLE_STATUS_CODES = [429, 503];
    DEFER_OPERATION_REGEX = /@(defer)\b/i;
    NEWLINE_SEPARATOR = "\r\n";
    BOUNDARY_HEADER_REGEX = /boundary="?([^=";]+)"?/i;
    HEADER_SEPARATOR = NEWLINE_SEPARATOR + NEWLINE_SEPARATOR;
  }
});

// node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/graphql-client/utilities.mjs
function formatErrorMessage(message2, client = CLIENT) {
  return message2.startsWith(`${client}`) ? message2 : `${client}: ${message2}`;
}
function getErrorMessage(error) {
  return error instanceof Error ? error.message : JSON.stringify(error);
}
function getErrorCause(error) {
  return error instanceof Error && error.cause ? error.cause : void 0;
}
function combineErrors(dataArray) {
  return dataArray.flatMap(({ errors }) => {
    return errors ?? [];
  });
}
function validateRetries({ client, retries }) {
  if (retries !== void 0 && (typeof retries !== "number" || retries < MIN_RETRIES || retries > MAX_RETRIES)) {
    throw new Error(`${client}: The provided "retries" value (${retries}) is invalid - it cannot be less than ${MIN_RETRIES} or greater than ${MAX_RETRIES}`);
  }
}
function getKeyValueIfValid(key, value) {
  return value && (typeof value !== "object" || Array.isArray(value) || typeof value === "object" && Object.keys(value).length > 0) ? { [key]: value } : {};
}
function buildDataObjectByPath(path, data) {
  if (path.length === 0) {
    return data;
  }
  const key = path.pop();
  const newData = {
    [key]: data
  };
  if (path.length === 0) {
    return newData;
  }
  return buildDataObjectByPath(path, newData);
}
function combineObjects(baseObject, newObject) {
  return Object.keys(newObject || {}).reduce((acc, key) => {
    if ((typeof newObject[key] === "object" || Array.isArray(newObject[key])) && baseObject[key]) {
      acc[key] = combineObjects(baseObject[key], newObject[key]);
      return acc;
    }
    acc[key] = newObject[key];
    return acc;
  }, Array.isArray(baseObject) ? [...baseObject] : { ...baseObject });
}
function buildCombinedDataObject([initialDatum, ...remainingData]) {
  return remainingData.reduce(combineObjects, { ...initialDatum });
}
var init_utilities = __esm({
  "node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/graphql-client/utilities.mjs"() {
    init_constants();
  }
});

// node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/graphql-client/http-fetch.mjs
function generateHttpFetch({ clientLogger, customFetchApi = fetch, client = CLIENT, defaultRetryWaitTime = RETRY_WAIT_TIME, retriableCodes = RETRIABLE_STATUS_CODES }) {
  const httpFetch = async (requestParams, count, maxRetries) => {
    const nextCount = count + 1;
    const maxTries = maxRetries + 1;
    let response;
    try {
      response = await customFetchApi(...requestParams);
      clientLogger({
        type: "HTTP-Response",
        content: {
          requestParams,
          response
        }
      });
      if (!response.ok && retriableCodes.includes(response.status) && nextCount <= maxTries) {
        throw new Error();
      }
      return response;
    } catch (error) {
      if (nextCount <= maxTries) {
        const retryAfter = response == null ? void 0 : response.headers.get("Retry-After");
        await sleep(retryAfter ? parseInt(retryAfter, 10) : defaultRetryWaitTime);
        clientLogger({
          type: "HTTP-Retry",
          content: {
            requestParams,
            lastResponse: response,
            retryAttempt: count,
            maxRetries
          }
        });
        return httpFetch(requestParams, nextCount, maxRetries);
      }
      throw new Error(formatErrorMessage(`${maxRetries > 0 ? `Attempted maximum number of ${maxRetries} network retries. Last message - ` : ""}${getErrorMessage(error)}`, client));
    }
  };
  return httpFetch;
}
async function sleep(waitTime) {
  return new Promise((resolve) => setTimeout(resolve, waitTime));
}
var init_http_fetch = __esm({
  "node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/graphql-client/http-fetch.mjs"() {
    init_constants();
    init_utilities();
  }
});

// node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/graphql-client/graphql-client.mjs
function createGraphQLClient({ headers, url, customFetchApi = fetch, retries = 0, logger }) {
  validateRetries({ client: CLIENT, retries });
  const config = {
    headers,
    url,
    retries
  };
  const clientLogger = generateClientLogger(logger);
  const httpFetch = generateHttpFetch({
    customFetchApi,
    clientLogger,
    defaultRetryWaitTime: RETRY_WAIT_TIME
  });
  const fetch2 = generateFetch(httpFetch, config);
  const request = generateRequest(fetch2);
  const requestStream = generateRequestStream(fetch2);
  return {
    config,
    fetch: fetch2,
    request,
    requestStream
  };
}
function generateClientLogger(logger) {
  return (logContent) => {
    if (logger) {
      logger(logContent);
    }
  };
}
async function processJSONResponse(response) {
  const { errors, data, extensions } = await response.json();
  return {
    ...getKeyValueIfValid("data", data),
    ...getKeyValueIfValid("extensions", extensions),
    ...errors || !data ? {
      errors: {
        networkStatusCode: response.status,
        message: formatErrorMessage(errors ? GQL_API_ERROR : NO_DATA_OR_ERRORS_ERROR),
        ...getKeyValueIfValid("graphQLErrors", errors),
        response
      }
    } : {}
  };
}
function generateFetch(httpFetch, { url, headers, retries }) {
  return async (operation, options = {}) => {
    const { variables, headers: overrideHeaders, url: overrideUrl, retries: overrideRetries } = options;
    const body = JSON.stringify({
      query: operation,
      variables
    });
    validateRetries({ client: CLIENT, retries: overrideRetries });
    const flatHeaders = Object.entries({
      ...headers,
      ...overrideHeaders
    }).reduce((headers2, [key, value]) => {
      headers2[key] = Array.isArray(value) ? value.join(", ") : value.toString();
      return headers2;
    }, {});
    if (!flatHeaders[SDK_VARIANT_HEADER] && !flatHeaders[SDK_VERSION_HEADER]) {
      flatHeaders[SDK_VARIANT_HEADER] = DEFAULT_SDK_VARIANT;
      flatHeaders[SDK_VERSION_HEADER] = DEFAULT_CLIENT_VERSION;
    }
    const fetchParams = [
      overrideUrl ?? url,
      {
        method: "POST",
        headers: flatHeaders,
        body
      }
    ];
    return httpFetch(fetchParams, 1, overrideRetries ?? retries);
  };
}
function generateRequest(fetch2) {
  return async (...props) => {
    if (DEFER_OPERATION_REGEX.test(props[0])) {
      throw new Error(formatErrorMessage("This operation will result in a streamable response - use requestStream() instead."));
    }
    try {
      const response = await fetch2(...props);
      const { status, statusText } = response;
      const contentType = response.headers.get("content-type") || "";
      if (!response.ok) {
        return {
          errors: {
            networkStatusCode: status,
            message: formatErrorMessage(statusText),
            response
          }
        };
      }
      if (!contentType.includes(CONTENT_TYPES.json)) {
        return {
          errors: {
            networkStatusCode: status,
            message: formatErrorMessage(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${contentType}`),
            response
          }
        };
      }
      return processJSONResponse(response);
    } catch (error) {
      return {
        errors: {
          message: getErrorMessage(error)
        }
      };
    }
  };
}
async function* getStreamBodyIterator(response) {
  const decoder2 = new TextDecoder();
  if (response.body[Symbol.asyncIterator]) {
    for await (const chunk of response.body) {
      yield decoder2.decode(chunk);
    }
  } else {
    const reader = response.body.getReader();
    let readResult;
    try {
      while (!(readResult = await reader.read()).done) {
        yield decoder2.decode(readResult.value);
      }
    } finally {
      reader.cancel();
    }
  }
}
function readStreamChunk(streamBodyIterator, boundary) {
  return {
    async *[Symbol.asyncIterator]() {
      try {
        let buffer = "";
        for await (const textChunk of streamBodyIterator) {
          buffer += textChunk;
          if (buffer.indexOf(boundary) > -1) {
            const lastBoundaryIndex = buffer.lastIndexOf(boundary);
            const fullResponses = buffer.slice(0, lastBoundaryIndex);
            const chunkBodies = fullResponses.split(boundary).filter((chunk) => chunk.trim().length > 0).map((chunk) => {
              const body = chunk.slice(chunk.indexOf(HEADER_SEPARATOR) + HEADER_SEPARATOR.length).trim();
              return body;
            });
            if (chunkBodies.length > 0) {
              yield chunkBodies;
            }
            buffer = buffer.slice(lastBoundaryIndex + boundary.length);
            if (buffer.trim() === `--`) {
              buffer = "";
            }
          }
        }
      } catch (error) {
        throw new Error(`Error occured while processing stream payload - ${getErrorMessage(error)}`);
      }
    }
  };
}
function createJsonResponseAsyncIterator(response) {
  return {
    async *[Symbol.asyncIterator]() {
      const processedResponse = await processJSONResponse(response);
      yield {
        ...processedResponse,
        hasNext: false
      };
    }
  };
}
function getResponseDataFromChunkBodies(chunkBodies) {
  return chunkBodies.map((value) => {
    try {
      return JSON.parse(value);
    } catch (error) {
      throw new Error(`Error in parsing multipart response - ${getErrorMessage(error)}`);
    }
  }).map((payload) => {
    const { data, incremental, hasNext, extensions, errors } = payload;
    if (!incremental) {
      return {
        data: data || {},
        ...getKeyValueIfValid("errors", errors),
        ...getKeyValueIfValid("extensions", extensions),
        hasNext
      };
    }
    const incrementalArray = incremental.map(({ data: data2, path, errors: errors2 }) => {
      return {
        data: data2 && path ? buildDataObjectByPath(path, data2) : {},
        ...getKeyValueIfValid("errors", errors2)
      };
    });
    return {
      data: incrementalArray.length === 1 ? incrementalArray[0].data : buildCombinedDataObject([
        ...incrementalArray.map(({ data: data2 }) => data2)
      ]),
      ...getKeyValueIfValid("errors", combineErrors(incrementalArray)),
      hasNext
    };
  });
}
function validateResponseData(responseErrors, combinedData) {
  if (responseErrors.length > 0) {
    throw new Error(GQL_API_ERROR, {
      cause: {
        graphQLErrors: responseErrors
      }
    });
  }
  if (Object.keys(combinedData).length === 0) {
    throw new Error(NO_DATA_OR_ERRORS_ERROR);
  }
}
function createMultipartResponseAsyncInterator(response, responseContentType) {
  var _a2;
  const boundaryHeader = (responseContentType ?? "").match(BOUNDARY_HEADER_REGEX);
  const boundary = `--${boundaryHeader ? boundaryHeader[1] : "-"}`;
  if (!((_a2 = response.body) == null ? void 0 : _a2.getReader) && !response.body[Symbol.asyncIterator]) {
    throw new Error("API multipart response did not return an iterable body", {
      cause: response
    });
  }
  const streamBodyIterator = getStreamBodyIterator(response);
  let combinedData = {};
  let responseExtensions;
  return {
    async *[Symbol.asyncIterator]() {
      var _a3;
      try {
        let streamHasNext = true;
        for await (const chunkBodies of readStreamChunk(streamBodyIterator, boundary)) {
          const responseData = getResponseDataFromChunkBodies(chunkBodies);
          responseExtensions = ((_a3 = responseData.find((datum) => datum.extensions)) == null ? void 0 : _a3.extensions) ?? responseExtensions;
          const responseErrors = combineErrors(responseData);
          combinedData = buildCombinedDataObject([
            combinedData,
            ...responseData.map(({ data }) => data)
          ]);
          streamHasNext = responseData.slice(-1)[0].hasNext;
          validateResponseData(responseErrors, combinedData);
          yield {
            ...getKeyValueIfValid("data", combinedData),
            ...getKeyValueIfValid("extensions", responseExtensions),
            hasNext: streamHasNext
          };
        }
        if (streamHasNext) {
          throw new Error(`Response stream terminated unexpectedly`);
        }
      } catch (error) {
        const cause = getErrorCause(error);
        yield {
          ...getKeyValueIfValid("data", combinedData),
          ...getKeyValueIfValid("extensions", responseExtensions),
          errors: {
            message: formatErrorMessage(getErrorMessage(error)),
            networkStatusCode: response.status,
            ...getKeyValueIfValid("graphQLErrors", cause == null ? void 0 : cause.graphQLErrors),
            response
          },
          hasNext: false
        };
      }
    }
  };
}
function generateRequestStream(fetch2) {
  return async (...props) => {
    if (!DEFER_OPERATION_REGEX.test(props[0])) {
      throw new Error(formatErrorMessage("This operation does not result in a streamable response - use request() instead."));
    }
    try {
      const response = await fetch2(...props);
      const { statusText } = response;
      if (!response.ok) {
        throw new Error(statusText, { cause: response });
      }
      const responseContentType = response.headers.get("content-type") || "";
      switch (true) {
        case responseContentType.includes(CONTENT_TYPES.json):
          return createJsonResponseAsyncIterator(response);
        case responseContentType.includes(CONTENT_TYPES.multipart):
          return createMultipartResponseAsyncInterator(response, responseContentType);
        default:
          throw new Error(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${responseContentType}`, { cause: response });
      }
    } catch (error) {
      return {
        async *[Symbol.asyncIterator]() {
          const response = getErrorCause(error);
          yield {
            errors: {
              message: formatErrorMessage(getErrorMessage(error)),
              ...getKeyValueIfValid("networkStatusCode", response == null ? void 0 : response.status),
              ...getKeyValueIfValid("response", response)
            },
            hasNext: false
          };
        }
      };
    }
  };
}
var init_graphql_client = __esm({
  "node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/graphql-client/graphql-client.mjs"() {
    init_http_fetch();
    init_constants();
    init_utilities();
  }
});

// node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/api-client-utilities/validations.mjs
function validateDomainAndGetStoreUrl({ client, storeDomain }) {
  try {
    if (!storeDomain || typeof storeDomain !== "string") {
      throw new Error();
    }
    const trimmedDomain = storeDomain.trim();
    const protocolUrl = trimmedDomain.match(/^https?:/) ? trimmedDomain : `https://${trimmedDomain}`;
    const url = new URL(protocolUrl);
    url.protocol = "https";
    return url.origin;
  } catch (_error) {
    throw new Error(`${client}: a valid store domain ("${storeDomain}") must be provided`);
  }
}
function validateApiVersion({ client, currentSupportedApiVersions, apiVersion, logger }) {
  const versionError = `${client}: the provided apiVersion ("${apiVersion}")`;
  const supportedVersion = `Currently supported API versions: ${currentSupportedApiVersions.join(", ")}`;
  if (!apiVersion || typeof apiVersion !== "string") {
    throw new Error(`${versionError} is invalid. ${supportedVersion}`);
  }
  const trimmedApiVersion = apiVersion.trim();
  if (!currentSupportedApiVersions.includes(trimmedApiVersion)) {
    if (logger) {
      logger({
        type: "Unsupported_Api_Version",
        content: {
          apiVersion,
          supportedApiVersions: currentSupportedApiVersions
        }
      });
    } else {
      console.warn(`${versionError} is likely deprecated or not supported. ${supportedVersion}`);
    }
  }
}
var init_validations = __esm({
  "node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/api-client-utilities/validations.mjs"() {
  }
});

// node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/api-client-utilities/api-versions.mjs
function getQuarterMonth(quarter) {
  const month = quarter * 3 - 2;
  return month === 10 ? month : `0${month}`;
}
function getPrevousVersion(year2, quarter, nQuarter) {
  const versionQuarter = quarter - nQuarter;
  if (versionQuarter <= 0) {
    return `${year2 - 1}-${getQuarterMonth(versionQuarter + 4)}`;
  }
  return `${year2}-${getQuarterMonth(versionQuarter)}`;
}
function getCurrentApiVersion() {
  const date = /* @__PURE__ */ new Date();
  const month = date.getUTCMonth();
  const year2 = date.getUTCFullYear();
  const quarter = Math.floor(month / 3 + 1);
  return {
    year: year2,
    quarter,
    version: `${year2}-${getQuarterMonth(quarter)}`
  };
}
function getCurrentSupportedApiVersions() {
  const { year: year2, quarter, version: currentVersion } = getCurrentApiVersion();
  const nextVersion = quarter === 4 ? `${year2 + 1}-01` : `${year2}-${getQuarterMonth(quarter + 1)}`;
  return [
    getPrevousVersion(year2, quarter, 3),
    getPrevousVersion(year2, quarter, 2),
    getPrevousVersion(year2, quarter, 1),
    currentVersion,
    nextVersion,
    "unstable"
  ];
}
var init_api_versions = __esm({
  "node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/api-client-utilities/api-versions.mjs"() {
  }
});

// node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/api-client-utilities/utilities.mjs
function generateGetHeaders(config) {
  return (customHeaders) => {
    return { ...customHeaders ?? {}, ...config.headers };
  };
}
function generateGetGQLClientParams({ getHeaders, getApiUrl }) {
  return (operation, options) => {
    const props = [operation];
    if (options && Object.keys(options).length > 0) {
      const { variables, apiVersion: propApiVersion, headers, retries } = options;
      props.push({
        ...variables ? { variables } : {},
        ...headers ? { headers: getHeaders(headers) } : {},
        ...propApiVersion ? { url: getApiUrl(propApiVersion) } : {},
        ...retries ? { retries } : {}
      });
    }
    return props;
  };
}
var init_utilities2 = __esm({
  "node_modules/@shopify/storefront-api-client/dist/graphql-client/dist/api-client-utilities/utilities.mjs"() {
  }
});

// node_modules/@shopify/storefront-api-client/dist/constants.mjs
var DEFAULT_CONTENT_TYPE, DEFAULT_SDK_VARIANT2, DEFAULT_CLIENT_VERSION2, PUBLIC_ACCESS_TOKEN_HEADER, PRIVATE_ACCESS_TOKEN_HEADER, SDK_VARIANT_HEADER2, SDK_VERSION_HEADER2, SDK_VARIANT_SOURCE_HEADER, CLIENT2;
var init_constants2 = __esm({
  "node_modules/@shopify/storefront-api-client/dist/constants.mjs"() {
    DEFAULT_CONTENT_TYPE = "application/json";
    DEFAULT_SDK_VARIANT2 = "storefront-api-client";
    DEFAULT_CLIENT_VERSION2 = "0.3.2";
    PUBLIC_ACCESS_TOKEN_HEADER = "X-Shopify-Storefront-Access-Token";
    PRIVATE_ACCESS_TOKEN_HEADER = "Shopify-Storefront-Private-Token";
    SDK_VARIANT_HEADER2 = "X-SDK-Variant";
    SDK_VERSION_HEADER2 = "X-SDK-Version";
    SDK_VARIANT_SOURCE_HEADER = "X-SDK-Variant-Source";
    CLIENT2 = "Storefront API Client";
  }
});

// node_modules/@shopify/storefront-api-client/dist/validations.mjs
function validatePrivateAccessTokenUsage(privateAccessToken) {
  if (privateAccessToken && typeof window !== "undefined") {
    throw new Error(`${CLIENT2}: private access tokens and headers should only be used in a server-to-server implementation. Use the public API access token in nonserver environments.`);
  }
}
function validateRequiredAccessTokens(publicAccessToken, privateAccessToken) {
  if (!publicAccessToken && !privateAccessToken) {
    throw new Error(`${CLIENT2}: a public or private access token must be provided`);
  }
  if (publicAccessToken && privateAccessToken) {
    throw new Error(`${CLIENT2}: only provide either a public or private access token`);
  }
}
var init_validations2 = __esm({
  "node_modules/@shopify/storefront-api-client/dist/validations.mjs"() {
    init_constants2();
  }
});

// node_modules/@shopify/storefront-api-client/dist/storefront-api-client.mjs
function createStorefrontApiClient({ storeDomain, apiVersion, publicAccessToken, privateAccessToken, clientName, retries = 0, customFetchApi, logger }) {
  const currentSupportedApiVersions = getCurrentSupportedApiVersions();
  const storeUrl = validateDomainAndGetStoreUrl({
    client: CLIENT2,
    storeDomain
  });
  const baseApiVersionValidationParams = {
    client: CLIENT2,
    currentSupportedApiVersions,
    logger
  };
  validateApiVersion({ ...baseApiVersionValidationParams, apiVersion });
  validateRequiredAccessTokens(publicAccessToken, privateAccessToken);
  validatePrivateAccessTokenUsage(privateAccessToken);
  const apiUrlFormatter = generateApiUrlFormatter(storeUrl, apiVersion, baseApiVersionValidationParams);
  const config = {
    storeDomain: storeUrl,
    apiVersion,
    ...publicAccessToken ? { publicAccessToken } : {
      privateAccessToken
    },
    headers: {
      "Content-Type": DEFAULT_CONTENT_TYPE,
      Accept: DEFAULT_CONTENT_TYPE,
      [SDK_VARIANT_HEADER2]: DEFAULT_SDK_VARIANT2,
      [SDK_VERSION_HEADER2]: DEFAULT_CLIENT_VERSION2,
      ...clientName ? { [SDK_VARIANT_SOURCE_HEADER]: clientName } : {},
      ...publicAccessToken ? { [PUBLIC_ACCESS_TOKEN_HEADER]: publicAccessToken } : { [PRIVATE_ACCESS_TOKEN_HEADER]: privateAccessToken }
    },
    apiUrl: apiUrlFormatter(),
    clientName
  };
  const graphqlClient = createGraphQLClient({
    headers: config.headers,
    url: config.apiUrl,
    retries,
    customFetchApi,
    logger
  });
  const getHeaders = generateGetHeaders(config);
  const getApiUrl = generateGetApiUrl(config, apiUrlFormatter);
  const getGQLClientParams = generateGetGQLClientParams({
    getHeaders,
    getApiUrl
  });
  const client = {
    config,
    getHeaders,
    getApiUrl,
    fetch: (...props) => {
      return graphqlClient.fetch(...getGQLClientParams(...props));
    },
    request: (...props) => {
      return graphqlClient.request(...getGQLClientParams(...props));
    },
    requestStream: (...props) => {
      return graphqlClient.requestStream(...getGQLClientParams(...props));
    }
  };
  return Object.freeze(client);
}
function generateApiUrlFormatter(storeUrl, defaultApiVersion, baseApiVersionValidationParams) {
  return (apiVersion) => {
    if (apiVersion) {
      validateApiVersion({
        ...baseApiVersionValidationParams,
        apiVersion
      });
    }
    const urlApiVersion = (apiVersion ?? defaultApiVersion).trim();
    return `${storeUrl}/api/${urlApiVersion}/graphql.json`;
  };
}
function generateGetApiUrl(config, apiUrlFormatter) {
  return (propApiVersion) => {
    return propApiVersion ? apiUrlFormatter(propApiVersion) : config.apiUrl;
  };
}
var init_storefront_api_client = __esm({
  "node_modules/@shopify/storefront-api-client/dist/storefront-api-client.mjs"() {
    init_graphql_client();
    init_validations();
    init_api_versions();
    init_utilities2();
    init_constants2();
    init_validations2();
  }
});

// node_modules/@shopify/storefront-api-client/dist/index.mjs
var dist_exports2 = {};
__export(dist_exports2, {
  createStorefrontApiClient: () => createStorefrontApiClient
});
var init_dist2 = __esm({
  "node_modules/@shopify/storefront-api-client/dist/index.mjs"() {
    init_storefront_api_client();
  }
});

// node_modules/@shopify/shopify-api/lib/clients/storefront/client.js
var require_client3 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/storefront/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storefrontClientClass = exports.StorefrontClient = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var storefront_api_client_1 = (init_dist2(), __toCommonJS(dist_exports2));
    var logger_1 = require_logger();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var error_1 = require_error();
    var runtime_1 = require_runtime();
    var common_1 = require_common();
    var StorefrontClient = class {
      constructor(params) {
        var _a2;
        const config = this.storefrontClass().config;
        if (!config.isCustomStoreApp && !params.session.accessToken) {
          throw new ShopifyErrors.MissingRequiredArgument("Missing access token when creating GraphQL client");
        }
        if (params.apiVersion) {
          const message2 = params.apiVersion === config.apiVersion ? `Storefront client has a redundant API version override to the default ${params.apiVersion}` : `Storefront client overriding default API version ${config.apiVersion} with ${params.apiVersion}`;
          (0, logger_1.logger)(config).debug(message2);
        }
        let accessToken;
        if (config.isCustomStoreApp) {
          accessToken = config.privateAppStorefrontAccessToken;
          if (!accessToken) {
            throw new error_1.MissingRequiredArgument("Custom store apps must set the privateAppStorefrontAccessToken property to call the Storefront API.");
          }
        } else {
          accessToken = params.session.accessToken;
          if (!accessToken) {
            throw new error_1.MissingRequiredArgument("Session missing access token.");
          }
        }
        this.session = params.session;
        this.apiVersion = params.apiVersion;
        this.client = (0, storefront_api_client_1.createStorefrontApiClient)({
          privateAccessToken: accessToken,
          apiVersion: (_a2 = this.apiVersion) !== null && _a2 !== void 0 ? _a2 : config.apiVersion,
          storeDomain: this.session.shop,
          customFetchApi: runtime_1.abstractFetch,
          logger: (0, common_1.clientLoggerFactory)(config),
          clientName: (0, common_1.getUserAgent)(config)
        });
      }
      query(params) {
        var _a2;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          (0, logger_1.logger)(this.storefrontClass().config).deprecated("10.0.0", "The query method is deprecated, and was replaced with the request method.\nSee the migration guide: https://github.com/Shopify/shopify-api-js/blob/main/packages/shopify-api/docs/migrating-to-v9.md#using-the-new-clients.");
          if (typeof params.data === "string" && params.data.length === 0 || Object.entries(params.data).length === 0) {
            throw new ShopifyErrors.MissingRequiredArgument("Query missing.");
          }
          let operation;
          let variables;
          if (typeof params.data === "string") {
            operation = params.data;
          } else {
            operation = params.data.query;
            variables = params.data.variables;
          }
          const headers = Object.fromEntries(Object.entries((_a2 = params === null || params === void 0 ? void 0 : params.extraHeaders) !== null && _a2 !== void 0 ? _a2 : {}).map(([key, value]) => [
            key,
            Array.isArray(value) ? value.join(", ") : value.toString()
          ]));
          const response = yield this.request(operation, {
            headers,
            retries: params.tries ? params.tries - 1 : void 0,
            variables
          });
          return { body: response, headers: {} };
        });
      }
      request(operation, options) {
        var _a2;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const response = yield this.client.request(operation, Object.assign({ apiVersion: this.apiVersion || this.storefrontClass().config.apiVersion }, options));
          if (response.errors) {
            const fetchResponse = response.errors.response;
            (0, common_1.throwFailedRequest)(response, fetchResponse, ((_a2 = options === null || options === void 0 ? void 0 : options.retries) !== null && _a2 !== void 0 ? _a2 : 0) > 0);
          }
          return response;
        });
      }
      storefrontClass() {
        return this.constructor;
      }
    };
    exports.StorefrontClient = StorefrontClient;
    function storefrontClientClass(params) {
      const { config } = params;
      class NewStorefrontClient extends StorefrontClient {
      }
      NewStorefrontClient.config = config;
      Reflect.defineProperty(NewStorefrontClient, "name", {
        value: "StorefrontClient"
      });
      return NewStorefrontClient;
    }
    exports.storefrontClientClass = storefrontClientClass;
  }
});

// node_modules/@shopify/shopify-api/lib/clients/storefront/index.js
var require_storefront = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/storefront/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storefrontClientClass = exports.StorefrontClient = void 0;
    var client_1 = require_client3();
    Object.defineProperty(exports, "StorefrontClient", { enumerable: true, get: function() {
      return client_1.StorefrontClient;
    } });
    Object.defineProperty(exports, "storefrontClientClass", { enumerable: true, get: function() {
      return client_1.storefrontClientClass;
    } });
  }
});

// node_modules/@shopify/shopify-api/lib/clients/graphql_proxy/graphql_proxy.js
var require_graphql_proxy = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/graphql_proxy/graphql_proxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.graphqlProxy = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var admin_1 = require_admin();
    function graphqlProxy(config) {
      return ({ session, rawBody }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!session.accessToken) {
          throw new ShopifyErrors.InvalidSession("Cannot proxy query. Session not authenticated.");
        }
        const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
        const client = new GraphqlClient({ session });
        let query;
        let variables;
        if (typeof rawBody === "string") {
          query = rawBody;
        } else {
          query = rawBody.query;
          variables = rawBody.variables;
        }
        if (!query) {
          throw new ShopifyErrors.MissingRequiredArgument("Query missing.");
        }
        const response = yield client.request(query, { variables });
        return { body: response, headers: {} };
      });
    }
    exports.graphqlProxy = graphqlProxy;
  }
});

// node_modules/@shopify/shopify-api/lib/clients/index.js
var require_clients = __commonJS({
  "node_modules/@shopify/shopify-api/lib/clients/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clientClasses = void 0;
    var admin_1 = require_admin();
    var storefront_1 = require_storefront();
    var graphql_proxy_1 = require_graphql_proxy();
    function clientClasses(config) {
      return {
        // We don't pass in the HttpClient because the RestClient inherits from it, and goes through the same setup process
        Rest: (0, admin_1.restClientClass)({ config }),
        Graphql: (0, admin_1.graphqlClientClass)({ config }),
        Storefront: (0, storefront_1.storefrontClientClass)({ config }),
        graphqlProxy: (0, graphql_proxy_1.graphqlProxy)(config)
      };
    }
    exports.clientClasses = clientClasses;
  }
});

// node_modules/@shopify/shopify-api/node_modules/isbot/index.js
var require_isbot = __commonJS({
  "node_modules/@shopify/shopify-api/node_modules/isbot/index.js"(exports, module) {
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      createIsbot: () => createIsbot,
      createIsbotFromList: () => createIsbotFromList,
      isbot: () => isbot,
      isbotMatch: () => isbotMatch,
      isbotMatches: () => isbotMatches,
      isbotNaive: () => isbotNaive,
      isbotPattern: () => isbotPattern,
      isbotPatterns: () => isbotPatterns,
      list: () => list,
      pattern: () => pattern
    });
    module.exports = __toCommonJS2(src_exports);
    var fullPattern = " daum[ /]| deusu/| yadirectfetcher|(?:^| )site|(?:^|[^g])news|(?<! (?:channel/|google/))google(?!(app|/google| pixel))|(?<! cu)bot(?:[^\\w]|_|$)|(?<! ya(?:yandex)?)search|(?<!(?:lib))http|(?<![hg]m)score|@[a-z]|\\(at\\)[a-z]|\\[at\\][a-z]|^12345|^<|^[\\w \\.\\-\\(?:\\):]+(?:/v?\\d+(\\.\\d+)?(?:\\.\\d{1,10})?)?(?:,|$)|^[^ ]{50,}$|^active|^ad muncher|^amaya|^anglesharp/|^avsdevicesdk/|^bidtellect/|^biglotron|^bot|^btwebclient/|^clamav[ /]|^client/|^cobweb/|^coccoc|^custom|^ddg[_-]android|^discourse|^dispatch/\\d|^downcast/|^duckduckgo|^facebook|^fdm[ /]\\d|^getright/|^gozilla/|^hatena|^hobbit|^hotzonu|^hwcdn/|^jeode/|^jetty/|^jigsaw|^linkdex|^metauri|^microsoft bits|^movabletype|^mozilla/\\d\\.\\d \\(compatible;?\\)$|^mozilla/\\d\\.\\d \\w*$|^navermailapp|^netsurf|^nuclei|^offline explorer|^php|^postman|^postrank|^python|^rank|^read|^reed|^rest|^serf|^snapchat|^space bison|^svn|^swcd |^taringa|^thumbor/|^tumblr/|^user-agent:|^valid|^venus/fedoraplanet|^w3c|^webbandit/|^webcopier|^wget|^whatsapp|^xenu link sleuth|^yahoo|^yandex|^zdm/\\d|^zoom marketplace/|^{{.*}}$|adbeat\\.com|appinsights|archive|ask jeeves/teoma|bit\\.ly/|bluecoat drtr|browsex|burpcollaborator|capture|catch|check|chrome-lighthouse|chromeframe|classifier|cloud|crawl|cryptoapi|dareboost|datanyze|dataprovider|dejaclick|dmbrowser|download|evc-batch/|feed|firephp|freesafeip|gomezagent|headless|httrack|hubspot marketing grader|hydra|ibisbrowser|images|inspect|iplabel|ips-agent|java(?!;)|library|mail\\.ru/|manager|monitor|neustar wpm|nutch|offbyone|optimize|pageburst|parser|perl|phantom|pingdom|powermarks|preview|proxy|ptst[ /]\\d|reader|reputation|resolver|retriever|rexx;|rigor|robot|rss|scan|scrape|server|sogou|sparkler/|speedcurve|spider|splash|statuscake|stumbleupon\\.com|supercleaner|synapse|synthetic|torrent|trace|transcoder|twingly recon|url|virtuoso|wappalyzer|webglance|webkit2png|whatcms/|wordpress|zgrab";
    var regularExpression = new RegExp(" daum[ /]| deusu\\/| yadirectfetcher|(?:^| )site|(?:^|[^g])news|(?<! (?:channel\\/|google\\/))google(?!(app|\\/google| pixel))|(?<! cu)bot(?:[^\\w]|_|$)|(?<! ya(?:yandex)?)search|(?<!(?:lib))http|(?<![hg]m)score|@[a-z]|\\(at\\)[a-z]|\\[at\\][a-z]|^12345|^<|^[\\w \\.\\-\\(?:\\):]+(?:\\/v?\\d+(\\.\\d+)?(?:\\.\\d{1,10})?)?(?:,|$)|^[^ ]{50,}$|^active|^ad muncher|^amaya|^anglesharp\\/|^avsdevicesdk\\/|^bidtellect\\/|^biglotron|^bot|^btwebclient\\/|^clamav[ /]|^client\\/|^cobweb\\/|^coccoc|^custom|^ddg[_-]android|^discourse|^dispatch\\/\\d|^downcast\\/|^duckduckgo|^facebook|^fdm[ /]\\d|^getright\\/|^gozilla\\/|^hatena|^hobbit|^hotzonu|^hwcdn\\/|^jeode\\/|^jetty\\/|^jigsaw|^linkdex|^metauri|^microsoft bits|^movabletype|^mozilla\\/\\d\\.\\d \\(compatible;?\\)$|^mozilla\\/\\d\\.\\d \\w*$|^navermailapp|^netsurf|^nuclei|^offline explorer|^php|^postman|^postrank|^python|^rank|^read|^reed|^rest|^serf|^snapchat|^space bison|^svn|^swcd |^taringa|^thumbor\\/|^tumblr\\/|^user-agent:|^valid|^venus\\/fedoraplanet|^w3c|^webbandit\\/|^webcopier|^wget|^whatsapp|^xenu link sleuth|^yahoo|^yandex|^zdm\\/\\d|^zoom marketplace\\/|^{{.*}}$|adbeat\\.com|appinsights|archive|ask jeeves\\/teoma|bit\\.ly\\/|bluecoat drtr|browsex|burpcollaborator|capture|catch|check|chrome-lighthouse|chromeframe|classifier|cloud|crawl|cryptoapi|dareboost|datanyze|dataprovider|dejaclick|dmbrowser|download|evc-batch\\/|feed|firephp|freesafeip|gomezagent|headless|httrack|hubspot marketing grader|hydra|ibisbrowser|images|inspect|iplabel|ips-agent|java(?!;)|library|mail\\.ru\\/|manager|monitor|neustar wpm|nutch|offbyone|optimize|pageburst|parser|perl|phantom|pingdom|powermarks|preview|proxy|ptst[ /]\\d|reader|reputation|resolver|retriever|rexx;|rigor|robot|rss|scan|scrape|server|sogou|sparkler\\/|speedcurve|spider|splash|statuscake|stumbleupon\\.com|supercleaner|synapse|synthetic|torrent|trace|transcoder|twingly recon|url|virtuoso|wappalyzer|webglance|webkit2png|whatcms\\/|wordpress|zgrab", "i");
    var patterns_default = [
      " daum[ /]",
      " deusu/",
      " yadirectfetcher",
      "(?:^| )site",
      "(?:^|[^g])news",
      "(?<! (?:channel/|google/))google(?!(app|/google| pixel))",
      "(?<! cu)bot(?:[^\\w]|_|$)",
      "(?<! ya(?:yandex)?)search",
      "(?<!(?:lib))http",
      "(?<![hg]m)score",
      "@[a-z]",
      "\\(at\\)[a-z]",
      "\\[at\\][a-z]",
      "^12345",
      "^<",
      "^[\\w \\.\\-\\(?:\\):]+(?:/v?\\d+(\\.\\d+)?(?:\\.\\d{1,10})?)?(?:,|$)",
      "^[^ ]{50,}$",
      "^active",
      "^ad muncher",
      "^amaya",
      "^anglesharp/",
      "^avsdevicesdk/",
      "^bidtellect/",
      "^biglotron",
      "^bot",
      "^btwebclient/",
      "^clamav[ /]",
      "^client/",
      "^cobweb/",
      "^coccoc",
      "^custom",
      "^ddg[_-]android",
      "^discourse",
      "^dispatch/\\d",
      "^downcast/",
      "^duckduckgo",
      "^facebook",
      "^fdm[ /]\\d",
      "^getright/",
      "^gozilla/",
      "^hatena",
      "^hobbit",
      "^hotzonu",
      "^hwcdn/",
      "^jeode/",
      "^jetty/",
      "^jigsaw",
      "^linkdex",
      "^metauri",
      "^microsoft bits",
      "^movabletype",
      "^mozilla/\\d\\.\\d \\(compatible;?\\)$",
      "^mozilla/\\d\\.\\d \\w*$",
      "^navermailapp",
      "^netsurf",
      "^nuclei",
      "^offline explorer",
      "^php",
      "^postman",
      "^postrank",
      "^python",
      "^rank",
      "^read",
      "^reed",
      "^rest",
      "^serf",
      "^snapchat",
      "^space bison",
      "^svn",
      "^swcd ",
      "^taringa",
      "^thumbor/",
      "^tumblr/",
      "^user-agent:",
      "^valid",
      "^venus/fedoraplanet",
      "^w3c",
      "^webbandit/",
      "^webcopier",
      "^wget",
      "^whatsapp",
      "^xenu link sleuth",
      "^yahoo",
      "^yandex",
      "^zdm/\\d",
      "^zoom marketplace/",
      "^{{.*}}$",
      "adbeat\\.com",
      "appinsights",
      "archive",
      "ask jeeves/teoma",
      "bit\\.ly/",
      "bluecoat drtr",
      "browsex",
      "burpcollaborator",
      "capture",
      "catch",
      "check",
      "chrome-lighthouse",
      "chromeframe",
      "classifier",
      "cloud",
      "crawl",
      "cryptoapi",
      "dareboost",
      "datanyze",
      "dataprovider",
      "dejaclick",
      "dmbrowser",
      "download",
      "evc-batch/",
      "feed",
      "firephp",
      "freesafeip",
      "gomezagent",
      "headless",
      "httrack",
      "hubspot marketing grader",
      "hydra",
      "ibisbrowser",
      "images",
      "inspect",
      "iplabel",
      "ips-agent",
      "java(?!;)",
      "library",
      "mail\\.ru/",
      "manager",
      "monitor",
      "neustar wpm",
      "nutch",
      "offbyone",
      "optimize",
      "pageburst",
      "parser",
      "perl",
      "phantom",
      "pingdom",
      "powermarks",
      "preview",
      "proxy",
      "ptst[ /]\\d",
      "reader",
      "reputation",
      "resolver",
      "retriever",
      "rexx;",
      "rigor",
      "robot",
      "rss",
      "scan",
      "scrape",
      "server",
      "sogou",
      "sparkler/",
      "speedcurve",
      "spider",
      "splash",
      "statuscake",
      "stumbleupon\\.com",
      "supercleaner",
      "synapse",
      "synthetic",
      "torrent",
      "trace",
      "transcoder",
      "twingly recon",
      "url",
      "virtuoso",
      "wappalyzer",
      "webglance",
      "webkit2png",
      "whatcms/",
      "wordpress",
      "zgrab"
    ];
    var naivePattern = /bot|spider|crawl|http|lighthouse/i;
    var pattern = regularExpression;
    var list = patterns_default;
    var isbotNaive = (userAgent) => Boolean(userAgent) && naivePattern.test(userAgent);
    var usedPattern;
    function isbot(userAgent) {
      if (typeof usedPattern === "undefined") {
        try {
          usedPattern = new RegExp(fullPattern, "i");
        } catch (error) {
          usedPattern = naivePattern;
        }
      }
      return Boolean(userAgent) && usedPattern.test(userAgent);
    }
    var createIsbot = (customPattern) => (userAgent) => Boolean(userAgent) && customPattern.test(userAgent);
    var createIsbotFromList = (list2) => {
      const pattern2 = new RegExp(list2.join("|"), "i");
      return (userAgent) => Boolean(userAgent) && pattern2.test(userAgent);
    };
    var isbotMatch = (userAgent) => {
      var _a2;
      return ((_a2 = userAgent == null ? void 0 : userAgent.match(pattern)) == null ? void 0 : _a2[0]) ?? null;
    };
    var isbotMatches = (userAgent) => list.map((part) => {
      var _a2;
      return (_a2 = userAgent == null ? void 0 : userAgent.match(new RegExp(part, "i"))) == null ? void 0 : _a2[0];
    }).filter(Boolean);
    var isbotPattern = (userAgent) => userAgent ? list.find((pattern2) => new RegExp(pattern2, "i").test(userAgent)) ?? null : null;
    var isbotPatterns = (userAgent) => userAgent ? list.filter((pattern2) => new RegExp(pattern2, "i").test(userAgent)) : [];
  }
});

// node_modules/@shopify/shopify-api/lib/utils/processed-query.js
var require_processed_query = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/processed-query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProcessedQuery = class _ProcessedQuery {
      static stringify(keyValuePairs) {
        if (!keyValuePairs || Object.keys(keyValuePairs).length === 0)
          return "";
        return new _ProcessedQuery().putAll(keyValuePairs).stringify();
      }
      constructor() {
        this.processedQuery = new URLSearchParams();
      }
      putAll(keyValuePairs) {
        Object.entries(keyValuePairs).forEach(([key, value]) => this.put(key, value));
        return this;
      }
      put(key, value) {
        if (Array.isArray(value)) {
          this.putArray(key, value);
        } else if ((value === null || value === void 0 ? void 0 : value.constructor) === Object) {
          this.putObject(key, value);
        } else {
          this.putSimple(key, value);
        }
      }
      putArray(key, value) {
        value.forEach((arrayValue) => this.processedQuery.append(`${key}[]`, `${arrayValue}`));
      }
      putObject(key, value) {
        Object.entries(value).forEach(([entry, entryValue]) => {
          this.processedQuery.append(`${key}[${entry}]`, `${entryValue}`);
        });
      }
      putSimple(key, value) {
        this.processedQuery.append(key, `${value}`);
      }
      stringify(omitQuestionMark = false) {
        const queryString = this.processedQuery.toString();
        return omitQuestionMark ? queryString : `?${queryString}`;
      }
    };
    exports.default = ProcessedQuery;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/safe-compare.js
var require_safe_compare = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/safe-compare.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeCompare = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var safeCompare = (strA, strB) => {
      if (typeof strA === typeof strB) {
        const enc = new TextEncoder();
        const buffA = enc.encode(JSON.stringify(strA));
        const buffB = enc.encode(JSON.stringify(strB));
        if (buffA.length === buffB.length) {
          return timingSafeEqual2(buffA, buffB);
        }
      } else {
        throw new ShopifyErrors.SafeCompareError(`Mismatched data types provided: ${typeof strA} and ${typeof strB}`);
      }
      return false;
    };
    exports.safeCompare = safeCompare;
    function timingSafeEqual2(bufA, bufB) {
      const viewA = new Uint8Array(bufA);
      const viewB = new Uint8Array(bufB);
      let out = 0;
      for (let i = 0; i < viewA.length; i++) {
        out |= viewA[i] ^ viewB[i];
      }
      return out === 0;
    }
  }
});

// node_modules/@shopify/shopify-api/lib/utils/hmac-validator.js
var require_hmac_validator = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/hmac-validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCurrentTimeInSec = exports.validateHmacString = exports.validateHmac = exports.generateLocalHmac = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var crypto_1 = require_crypto();
    var types_1 = require_types();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var safe_compare_1 = require_safe_compare();
    var processed_query_1 = tslib_1.__importDefault(require_processed_query());
    var HMAC_TIMESTAMP_PERMITTED_CLOCK_TOLERANCE_SEC = 90;
    function stringifyQueryForAdmin(query) {
      const processedQuery = new processed_query_1.default();
      Object.keys(query).sort((val1, val2) => val1.localeCompare(val2)).forEach((key) => processedQuery.put(key, query[key]));
      return processedQuery.stringify(true);
    }
    function stringifyQueryForAppProxy(query) {
      return Object.entries(query).sort(([val1], [val2]) => val1.localeCompare(val2)).reduce((acc, [key, value]) => {
        return `${acc}${key}=${Array.isArray(value) ? value.join(",") : value}`;
      }, "");
    }
    function generateLocalHmac(config) {
      return (params, signator = "admin") => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { hmac, signature } = params, query = tslib_1.__rest(params, ["hmac", "signature"]);
        const queryString = signator === "admin" ? stringifyQueryForAdmin(query) : stringifyQueryForAppProxy(query);
        return (0, crypto_1.createSHA256HMAC)(config.apiSecretKey, queryString, types_1.HashFormat.Hex);
      });
    }
    exports.generateLocalHmac = generateLocalHmac;
    function validateHmac(config) {
      return (query, { signator } = { signator: "admin" }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (signator === "admin" && !query.hmac) {
          throw new ShopifyErrors.InvalidHmacError("Query does not contain an HMAC value.");
        }
        if (signator === "appProxy" && !query.signature) {
          throw new ShopifyErrors.InvalidHmacError("Query does not contain a signature value.");
        }
        validateHmacTimestamp(query);
        const hmac = signator === "appProxy" ? query.signature : query.hmac;
        const localHmac = yield generateLocalHmac(config)(query, signator);
        return (0, safe_compare_1.safeCompare)(hmac, localHmac);
      });
    }
    exports.validateHmac = validateHmac;
    function validateHmacString(config, data, hmac, format) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const localHmac = yield (0, crypto_1.createSHA256HMAC)(config.apiSecretKey, data, format);
        return (0, safe_compare_1.safeCompare)(hmac, localHmac);
      });
    }
    exports.validateHmacString = validateHmacString;
    function getCurrentTimeInSec() {
      return Math.trunc(Date.now() / 1e3);
    }
    exports.getCurrentTimeInSec = getCurrentTimeInSec;
    function validateHmacTimestamp(query) {
      if (Math.abs(getCurrentTimeInSec() - Number(query.timestamp)) > HMAC_TIMESTAMP_PERMITTED_CLOCK_TOLERANCE_SEC) {
        throw new ShopifyErrors.InvalidHmacError("HMAC timestamp is outside of the tolerance range");
      }
    }
  }
});

// node_modules/@shopify/shopify-api/lib/auth/decode-host.js
var require_decode_host = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/decode-host.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeHost = void 0;
    function decodeHost(host) {
      return atob(host);
    }
    exports.decodeHost = decodeHost;
  }
});

// node_modules/@shopify/shopify-api/lib/utils/shop-admin-url-helper.js
var require_shop_admin_url_helper = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/shop-admin-url-helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.legacyUrlToShopAdminUrl = exports.shopAdminUrlToLegacyUrl = void 0;
    function shopAdminUrlToLegacyUrl(shopAdminUrl) {
      const shopUrl = removeProtocol(shopAdminUrl);
      const isShopAdminUrl = shopUrl.split(".")[0] === "admin";
      if (!isShopAdminUrl) {
        return null;
      }
      const regex = new RegExp(`admin\\..+/store/([^/]+)`);
      const matches = shopUrl.match(regex);
      if (matches && matches.length === 2) {
        const shopName = matches[1];
        const isSpinUrl = shopUrl.includes("spin.dev/store/");
        if (isSpinUrl) {
          return spinAdminUrlToLegacyUrl(shopUrl);
        } else {
          return `${shopName}.myshopify.com`;
        }
      } else {
        return null;
      }
    }
    exports.shopAdminUrlToLegacyUrl = shopAdminUrlToLegacyUrl;
    function legacyUrlToShopAdminUrl(legacyAdminUrl) {
      const shopUrl = removeProtocol(legacyAdminUrl);
      const regex = new RegExp(`(.+)\\.myshopify\\.com$`);
      const matches = shopUrl.match(regex);
      if (matches && matches.length === 2) {
        const shopName = matches[1];
        return `admin.shopify.com/store/${shopName}`;
      } else {
        const isSpinUrl = shopUrl.endsWith("spin.dev");
        if (isSpinUrl) {
          return spinLegacyUrlToAdminUrl(shopUrl);
        } else {
          return null;
        }
      }
    }
    exports.legacyUrlToShopAdminUrl = legacyUrlToShopAdminUrl;
    function spinAdminUrlToLegacyUrl(shopAdminUrl) {
      const spinRegex = new RegExp(`admin\\.web\\.(.+\\.spin\\.dev)/store/(.+)`);
      const spinMatches = shopAdminUrl.match(spinRegex);
      if (spinMatches && spinMatches.length === 3) {
        const spinUrl = spinMatches[1];
        const shopName = spinMatches[2];
        return `${shopName}.shopify.${spinUrl}`;
      } else {
        return null;
      }
    }
    function spinLegacyUrlToAdminUrl(legacyAdminUrl) {
      const spinRegex = new RegExp(`(.+)\\.shopify\\.(.+\\.spin\\.dev)`);
      const spinMatches = legacyAdminUrl.match(spinRegex);
      if (spinMatches && spinMatches.length === 3) {
        const shopName = spinMatches[1];
        const spinUrl = spinMatches[2];
        return `admin.web.${spinUrl}/store/${shopName}`;
      } else {
        return null;
      }
    }
    function removeProtocol(url) {
      return url.replace(/^https?:\/\//, "").replace(/\/$/, "");
    }
  }
});

// node_modules/@shopify/shopify-api/lib/utils/shop-validator.js
var require_shop_validator = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/shop-validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sanitizeHost = exports.sanitizeShop = void 0;
    var error_1 = require_error();
    var decode_host_1 = require_decode_host();
    var shop_admin_url_helper_1 = require_shop_admin_url_helper();
    function sanitizeShop(config) {
      return (shop, throwOnInvalid = false) => {
        let shopUrl = shop;
        const domainsRegex = ["myshopify\\.com", "shopify\\.com", "myshopify\\.io"];
        if (config.customShopDomains) {
          domainsRegex.push(...config.customShopDomains.map((regex) => typeof regex === "string" ? regex : regex.source));
        }
        const shopUrlRegex = new RegExp(`^[a-zA-Z0-9][a-zA-Z0-9-_]*\\.(${domainsRegex.join("|")})[/]*$`);
        const shopAdminRegex = new RegExp(`^admin\\.(${domainsRegex.join("|")})/store/([a-zA-Z0-9][a-zA-Z0-9-_]*)$`);
        const isShopAdminUrl = shopAdminRegex.test(shopUrl);
        if (isShopAdminUrl) {
          shopUrl = (0, shop_admin_url_helper_1.shopAdminUrlToLegacyUrl)(shopUrl) || "";
        }
        const sanitizedShop = shopUrlRegex.test(shopUrl) ? shopUrl : null;
        if (!sanitizedShop && throwOnInvalid) {
          throw new error_1.InvalidShopError("Received invalid shop argument");
        }
        return sanitizedShop;
      };
    }
    exports.sanitizeShop = sanitizeShop;
    function sanitizeHost() {
      return (host, throwOnInvalid = false) => {
        const base64regex = /^[0-9a-zA-Z+/]+={0,2}$/;
        let sanitizedHost = base64regex.test(host) ? host : null;
        if (sanitizedHost) {
          const { hostname } = new URL(`https://${(0, decode_host_1.decodeHost)(sanitizedHost)}`);
          const originsRegex = [
            "myshopify\\.com",
            "shopify\\.com",
            "myshopify\\.io",
            "spin\\.dev"
          ];
          const hostRegex = new RegExp(`\\.(${originsRegex.join("|")})$`);
          if (!hostRegex.test(hostname)) {
            sanitizedHost = null;
          }
        }
        if (!sanitizedHost && throwOnInvalid) {
          throw new error_1.InvalidHostError("Received invalid host argument");
        }
        return sanitizedHost;
      };
    }
    exports.sanitizeHost = sanitizeHost;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/types.js
var require_types4 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STATE_COOKIE_NAME = exports.SESSION_COOKIE_NAME = void 0;
    exports.SESSION_COOKIE_NAME = "shopify_app_session";
    exports.STATE_COOKIE_NAME = "shopify_app_state";
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/nonce.js
var require_nonce = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/nonce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nonce = void 0;
    var crypto_1 = require_crypto();
    function nonce() {
      const length = 15;
      const bytes = crypto_1.crypto.getRandomValues ? crypto_1.crypto.getRandomValues(new Uint8Array(length)) : crypto_1.crypto.randomBytes(length);
      const nonce2 = bytes.map((byte) => {
        return byte % 10;
      }).join("");
      return nonce2;
    }
    exports.nonce = nonce;
  }
});

// node_modules/uuid/dist/commonjs-browser/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/rng.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rng;
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues(rnds8);
    }
  }
});

// node_modules/uuid/dist/commonjs-browser/regex.js
var require_regex = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/validate.js
var require_validate = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    var _default = validate;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/stringify.js
var require_stringify = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }
    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _default = stringify;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.unsafeStringify)(b);
    }
    var _default = v1;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/parse.js
var require_parse = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse2(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse2;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v35.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.URL = exports.DNS = void 0;
    exports.default = v35;
    var _stringify = require_stringify();
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = URL2;
    function v35(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  }
});

// node_modules/uuid/dist/commonjs-browser/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/md5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function md5(bytes) {
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = new Uint8Array(msg.length);
        for (let i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    function md5ToHexEncodedArray(input) {
      const output = [];
      const length32 = input.length * 32;
      const hexTab = "0123456789abcdef";
      for (let i = 0; i < length32; i += 8) {
        const x = input[i >> 5] >>> i % 32 & 255;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
        output.push(hex);
      }
      return output;
    }
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    function wordsToMd5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[getOutputLength(len) - 1] = len;
      let a = 1732584193;
      let b = -271733879;
      let c = -1732584194;
      let d = 271733878;
      for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }
      return [a, b, c, d];
    }
    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }
      const length8 = input.length * 8;
      const output = new Uint32Array(getOutputLength(length8));
      for (let i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 255) << i % 32;
      }
      return output;
    }
    function safeAdd(x, y) {
      const lsw = (x & 65535) + (y & 65535);
      const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    var _default = md5;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v3.js
var require_v3 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/native.js
var require_native = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/native.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var _default = {
      randomUUID
    };
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      if (_native.default.randomUUID && !buf && !options) {
        return _native.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    var _default = v4;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/sha1.js
var require_sha1 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/sha1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;
        case 1:
          return x ^ y ^ z;
        case 2:
          return x & y ^ x & z ^ y & z;
        case 3:
          return x ^ y ^ z;
      }
    }
    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }
    function sha1(bytes) {
      const K = [1518500249, 1859775393, 2400959708, 3395469782];
      const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = [];
        for (let i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        bytes = Array.prototype.slice.call(bytes);
      }
      bytes.push(128);
      const l = bytes.length / 4 + 2;
      const N = Math.ceil(l / 16);
      const M = new Array(N);
      for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
          arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
      }
      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
          W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
          const s = Math.floor(t / 20);
          const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }
      return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
    }
    var _default = sha1;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/nil.js
var require_nil = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/nil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/version.js
var require_version2 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    var _default = version;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/index.js
var require_commonjs_browser = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: function get() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function get() {
        return _parse.default;
      }
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function get() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function get() {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function get() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function get() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function get() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function get() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function get() {
        return _version.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version2());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/@shopify/shopify-api/lib/session/session.js
var require_session = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/session.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Session = void 0;
    var error_1 = require_error();
    var scopes_1 = require_scopes();
    var propertiesToSave = [
      "id",
      "shop",
      "state",
      "isOnline",
      "scope",
      "accessToken",
      "expires",
      "onlineAccessInfo"
    ];
    var Session = class _Session {
      static fromPropertyArray(entries) {
        if (!Array.isArray(entries)) {
          throw new error_1.InvalidSession("The parameter is not an array: a Session cannot be created from this object.");
        }
        const obj = Object.fromEntries(entries.filter(([_key, value]) => value !== null && value !== void 0).map(([key, value]) => {
          switch (key.toLowerCase()) {
            case "isonline":
              return ["isOnline", value];
            case "accesstoken":
              return ["accessToken", value];
            case "onlineaccessinfo":
              return ["onlineAccessInfo", value];
            default:
              return [key.toLowerCase(), value];
          }
        }).map(([key, value]) => {
          switch (key) {
            case "isOnline":
              if (typeof value === "string") {
                return [key, value.toString().toLowerCase() === "true"];
              } else if (typeof value === "number") {
                return [key, Boolean(value)];
              }
              return [key, value];
            case "scope":
              return [key, value.toString()];
            case "expires":
              return [key, value ? new Date(Number(value)) : void 0];
            case "onlineAccessInfo":
              return [
                key,
                {
                  associated_user: {
                    id: Number(value)
                  }
                }
              ];
            default:
              return [key, value];
          }
        }));
        Object.setPrototypeOf(obj, _Session.prototype);
        return obj;
      }
      constructor(params) {
        Object.assign(this, params);
      }
      /**
       * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.
       */
      isActive(scopes) {
        return !this.isScopeChanged(scopes) && Boolean(this.accessToken) && !this.isExpired();
      }
      /**
       * Whether the access token has the given scopes.
       */
      isScopeChanged(scopes) {
        const scopesObject = scopes instanceof scopes_1.AuthScopes ? scopes : new scopes_1.AuthScopes(scopes);
        return !scopesObject.equals(this.scope);
      }
      /**
       * Whether the access token is expired.
       */
      isExpired(withinMillisecondsOfExpiry = 0) {
        return Boolean(this.expires && this.expires.getTime() - withinMillisecondsOfExpiry < Date.now());
      }
      /**
       * Converts an object with data into a Session.
       */
      toObject() {
        const object = {
          id: this.id,
          shop: this.shop,
          state: this.state,
          isOnline: this.isOnline
        };
        if (this.scope) {
          object.scope = this.scope;
        }
        if (this.expires) {
          object.expires = this.expires;
        }
        if (this.accessToken) {
          object.accessToken = this.accessToken;
        }
        if (this.onlineAccessInfo) {
          object.onlineAccessInfo = this.onlineAccessInfo;
        }
        return object;
      }
      /**
       * Checks whether the given session is equal to this session.
       */
      equals(other) {
        if (!other)
          return false;
        const mandatoryPropsMatch = this.id === other.id && this.shop === other.shop && this.state === other.state && this.isOnline === other.isOnline;
        if (!mandatoryPropsMatch)
          return false;
        const copyA = this.toPropertyArray();
        copyA.sort(([k1], [k2]) => k1 < k2 ? -1 : 1);
        const copyB = other.toPropertyArray();
        copyB.sort(([k1], [k2]) => k1 < k2 ? -1 : 1);
        return JSON.stringify(copyA) === JSON.stringify(copyB);
      }
      /**
       * Converts the session into an array of key-value pairs.
       */
      toPropertyArray() {
        return Object.entries(this).filter(([key, value]) => propertiesToSave.includes(key) && value !== void 0 && value !== null).map(([key, value]) => {
          var _a2;
          switch (key) {
            case "expires":
              return [key, value ? value.getTime() : void 0];
            case "onlineAccessInfo":
              return [key, (_a2 = value === null || value === void 0 ? void 0 : value.associated_user) === null || _a2 === void 0 ? void 0 : _a2.id];
            default:
              return [key, value];
          }
        });
      }
    };
    exports.Session = Session;
  }
});

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default, isCryptoKey;
var init_webcrypto = __esm({
  "node_modules/jose/dist/browser/runtime/webcrypto.js"() {
    webcrypto_default = crypto;
    isCryptoKey = (key) => key instanceof CryptoKey;
  }
});

// node_modules/jose/dist/browser/runtime/digest.js
var digest, digest_default;
var init_digest = __esm({
  "node_modules/jose/dist/browser/runtime/digest.js"() {
    init_webcrypto();
    digest = async (algorithm, data) => {
      const subtleDigest = `SHA-${algorithm.slice(-3)}`;
      return new Uint8Array(await webcrypto_default.subtle.digest(subtleDigest, data));
    };
    digest_default = digest;
  }
});

// node_modules/jose/dist/browser/lib/buffer_utils.js
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i);
    i += buffer.length;
  }
  return buf;
}
function p2s(alg, p2sInput) {
  return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);
}
function writeUInt32BE(buf, value, offset) {
  if (value < 0 || value >= MAX_INT32) {
    throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
  }
  buf.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset);
}
function uint64be(value) {
  const high = Math.floor(value / MAX_INT32);
  const low = value % MAX_INT32;
  const buf = new Uint8Array(8);
  writeUInt32BE(buf, high, 0);
  writeUInt32BE(buf, low, 4);
  return buf;
}
function uint32be(value) {
  const buf = new Uint8Array(4);
  writeUInt32BE(buf, value);
  return buf;
}
function lengthAndInput(input) {
  return concat(uint32be(input.length), input);
}
async function concatKdf(secret, bits, value) {
  const iterations = Math.ceil((bits >> 3) / 32);
  const res = new Uint8Array(iterations * 32);
  for (let iter = 0; iter < iterations; iter++) {
    const buf = new Uint8Array(4 + secret.length + value.length);
    buf.set(uint32be(iter + 1));
    buf.set(secret, 4);
    buf.set(value, 4 + secret.length);
    res.set(await digest_default("sha256", buf), iter * 32);
  }
  return res.slice(0, bits >> 3);
}
var encoder, decoder, MAX_INT32;
var init_buffer_utils = __esm({
  "node_modules/jose/dist/browser/lib/buffer_utils.js"() {
    init_digest();
    encoder = new TextEncoder();
    decoder = new TextDecoder();
    MAX_INT32 = 2 ** 32;
  }
});

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64, encode, decodeBase64, decode;
var init_base64url = __esm({
  "node_modules/jose/dist/browser/runtime/base64url.js"() {
    init_buffer_utils();
    encodeBase64 = (input) => {
      let unencoded = input;
      if (typeof unencoded === "string") {
        unencoded = encoder.encode(unencoded);
      }
      const CHUNK_SIZE = 32768;
      const arr = [];
      for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
      }
      return btoa(arr.join(""));
    };
    encode = (input) => {
      return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    };
    decodeBase64 = (encoded) => {
      const binary = atob(encoded);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    };
    decode = (input) => {
      let encoded = input;
      if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
      }
      encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
      try {
        return decodeBase64(encoded);
      } catch {
        throw new TypeError("The input to be decoded is not correctly encoded.");
      }
    };
  }
});

// node_modules/jose/dist/browser/util/errors.js
var errors_exports = {};
__export(errors_exports, {
  JOSEAlgNotAllowed: () => JOSEAlgNotAllowed,
  JOSEError: () => JOSEError,
  JOSENotSupported: () => JOSENotSupported,
  JWEDecryptionFailed: () => JWEDecryptionFailed,
  JWEInvalid: () => JWEInvalid,
  JWKInvalid: () => JWKInvalid,
  JWKSInvalid: () => JWKSInvalid,
  JWKSMultipleMatchingKeys: () => JWKSMultipleMatchingKeys,
  JWKSNoMatchingKey: () => JWKSNoMatchingKey,
  JWKSTimeout: () => JWKSTimeout,
  JWSInvalid: () => JWSInvalid,
  JWSSignatureVerificationFailed: () => JWSSignatureVerificationFailed,
  JWTClaimValidationFailed: () => JWTClaimValidationFailed,
  JWTExpired: () => JWTExpired,
  JWTInvalid: () => JWTInvalid
});
var JOSEError, JWTClaimValidationFailed, JWTExpired, JOSEAlgNotAllowed, JOSENotSupported, JWEDecryptionFailed, JWEInvalid, JWSInvalid, JWTInvalid, JWKInvalid, JWKSInvalid, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, JWKSTimeout, JWSSignatureVerificationFailed;
var init_errors = __esm({
  "node_modules/jose/dist/browser/util/errors.js"() {
    JOSEError = class extends Error {
      static get code() {
        return "ERR_JOSE_GENERIC";
      }
      constructor(message2) {
        var _a2;
        super(message2);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        (_a2 = Error.captureStackTrace) == null ? void 0 : _a2.call(Error, this, this.constructor);
      }
    };
    JWTClaimValidationFailed = class extends JOSEError {
      static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
      }
      constructor(message2, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JWTExpired = class extends JOSEError {
      static get code() {
        return "ERR_JWT_EXPIRED";
      }
      constructor(message2, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JOSEAlgNotAllowed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    };
    JOSENotSupported = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
      }
    };
    JWEDecryptionFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_DECRYPTION_FAILED";
        this.message = "decryption operation failed";
      }
      static get code() {
        return "ERR_JWE_DECRYPTION_FAILED";
      }
    };
    JWEInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_INVALID";
      }
      static get code() {
        return "ERR_JWE_INVALID";
      }
    };
    JWSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
      static get code() {
        return "ERR_JWS_INVALID";
      }
    };
    JWTInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
      static get code() {
        return "ERR_JWT_INVALID";
      }
    };
    JWKInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWK_INVALID";
      }
      static get code() {
        return "ERR_JWK_INVALID";
      }
    };
    JWKSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
      static get code() {
        return "ERR_JWKS_INVALID";
      }
    };
    JWKSNoMatchingKey = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
      }
    };
    JWKSMultipleMatchingKeys = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    };
    JWKSTimeout = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_TIMEOUT";
        this.message = "request timed out";
      }
      static get code() {
        return "ERR_JWKS_TIMEOUT";
      }
    };
    JWSSignatureVerificationFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
      }
      static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/random.js
var random_default;
var init_random = __esm({
  "node_modules/jose/dist/browser/runtime/random.js"() {
    init_webcrypto();
    random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);
  }
});

// node_modules/jose/dist/browser/lib/iv.js
function bitLength(alg) {
  switch (alg) {
    case "A128GCM":
    case "A128GCMKW":
    case "A192GCM":
    case "A192GCMKW":
    case "A256GCM":
    case "A256GCMKW":
      return 96;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return 128;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var iv_default;
var init_iv = __esm({
  "node_modules/jose/dist/browser/lib/iv.js"() {
    init_errors();
    init_random();
    iv_default = (alg) => random_default(new Uint8Array(bitLength(alg) >> 3));
  }
});

// node_modules/jose/dist/browser/lib/check_iv_length.js
var checkIvLength, check_iv_length_default;
var init_check_iv_length = __esm({
  "node_modules/jose/dist/browser/lib/check_iv_length.js"() {
    init_errors();
    init_iv();
    checkIvLength = (enc, iv) => {
      if (iv.length << 3 !== bitLength(enc)) {
        throw new JWEInvalid("Invalid Initialization Vector length");
      }
    };
    check_iv_length_default = checkIvLength;
  }
});

// node_modules/jose/dist/browser/runtime/check_cek_length.js
var checkCekLength, check_cek_length_default;
var init_check_cek_length = __esm({
  "node_modules/jose/dist/browser/runtime/check_cek_length.js"() {
    init_errors();
    checkCekLength = (cek, expected) => {
      const actual = cek.byteLength << 3;
      if (actual !== expected) {
        throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
      }
    };
    check_cek_length_default = checkCekLength;
  }
});

// node_modules/jose/dist/browser/runtime/timing_safe_equal.js
var timingSafeEqual, timing_safe_equal_default;
var init_timing_safe_equal = __esm({
  "node_modules/jose/dist/browser/runtime/timing_safe_equal.js"() {
    timingSafeEqual = (a, b) => {
      if (!(a instanceof Uint8Array)) {
        throw new TypeError("First argument must be a buffer");
      }
      if (!(b instanceof Uint8Array)) {
        throw new TypeError("Second argument must be a buffer");
      }
      if (a.length !== b.length) {
        throw new TypeError("Input buffers must have the same length");
      }
      const len = a.length;
      let out = 0;
      let i = -1;
      while (++i < len) {
        out |= a[i] ^ b[i];
      }
      return out === 0;
    };
    timing_safe_equal_default = timingSafeEqual;
  }
});

// node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
function checkEncCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "A128GCM":
    case "A192GCM":
    case "A256GCM": {
      if (!isAlgorithm(key.algorithm, "AES-GCM"))
        throw unusable("AES-GCM");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (!isAlgorithm(key.algorithm, "AES-KW"))
        throw unusable("AES-KW");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "ECDH": {
      switch (key.algorithm.name) {
        case "ECDH":
        case "X25519":
        case "X448":
          break;
        default:
          throw unusable("ECDH, X25519, or X448");
      }
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW":
      if (!isAlgorithm(key.algorithm, "PBKDF2"))
        throw unusable("PBKDF2");
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
        throw unusable("RSA-OAEP");
      const expected = parseInt(alg.slice(9), 10) || 1;
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
var init_crypto_key = __esm({
  "node_modules/jose/dist/browser/lib/crypto_key.js"() {
  }
});

// node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types2) {
  var _a2;
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if ((_a2 = actual.constructor) == null ? void 0 : _a2.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}
var invalid_key_input_default;
var init_invalid_key_input = __esm({
  "node_modules/jose/dist/browser/lib/invalid_key_input.js"() {
    invalid_key_input_default = (actual, ...types2) => {
      return message("Key must be ", actual, ...types2);
    };
  }
});

// node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default, types;
var init_is_key_like = __esm({
  "node_modules/jose/dist/browser/runtime/is_key_like.js"() {
    init_webcrypto();
    is_key_like_default = (key) => {
      return isCryptoKey(key);
    };
    types = ["CryptoKey"];
  }
});

// node_modules/jose/dist/browser/runtime/decrypt.js
async function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["decrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const expectedTag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  let macCheckPassed;
  try {
    macCheckPassed = timing_safe_equal_default(tag, expectedTag);
  } catch {
  }
  if (!macCheckPassed) {
    throw new JWEDecryptionFailed();
  }
  let plaintext;
  try {
    plaintext = new Uint8Array(await webcrypto_default.subtle.decrypt({ iv, name: "AES-CBC" }, encKey, ciphertext));
  } catch {
  }
  if (!plaintext) {
    throw new JWEDecryptionFailed();
  }
  return plaintext;
}
async function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["decrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "decrypt");
    encKey = cek;
  }
  try {
    return new Uint8Array(await webcrypto_default.subtle.decrypt({
      additionalData: aad,
      iv,
      name: "AES-GCM",
      tagLength: 128
    }, encKey, concat(ciphertext, tag)));
  } catch {
    throw new JWEDecryptionFailed();
  }
}
var decrypt, decrypt_default;
var init_decrypt = __esm({
  "node_modules/jose/dist/browser/runtime/decrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_timing_safe_equal();
    init_errors();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    decrypt = async (enc, cek, ciphertext, iv, tag, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
      }
      if (!iv) {
        throw new JWEInvalid("JWE Initialization Vector missing");
      }
      if (!tag) {
        throw new JWEInvalid("JWE Authentication Tag missing");
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    decrypt_default = decrypt;
  }
});

// node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint, is_disjoint_default;
var init_is_disjoint = __esm({
  "node_modules/jose/dist/browser/lib/is_disjoint.js"() {
    isDisjoint = (...headers) => {
      const sources = headers.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    };
    is_disjoint_default = isDisjoint;
  }
});

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var init_is_object = __esm({
  "node_modules/jose/dist/browser/lib/is_object.js"() {
  }
});

// node_modules/jose/dist/browser/runtime/bogus.js
var bogusWebCrypto, bogus_default;
var init_bogus = __esm({
  "node_modules/jose/dist/browser/runtime/bogus.js"() {
    bogusWebCrypto = [
      { hash: "SHA-256", name: "HMAC" },
      true,
      ["sign"]
    ];
    bogus_default = bogusWebCrypto;
  }
});

// node_modules/jose/dist/browser/runtime/aeskw.js
function checkKeySize(key, alg) {
  if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {
    throw new TypeError(`Invalid key size for alg: ${alg}`);
  }
}
function getCryptoKey(key, alg, usage) {
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "AES-KW", true, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
var wrap, unwrap;
var init_aeskw = __esm({
  "node_modules/jose/dist/browser/runtime/aeskw.js"() {
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    wrap = async (alg, key, cek) => {
      const cryptoKey = await getCryptoKey(key, alg, "wrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, cryptoKey, "AES-KW"));
    };
    unwrap = async (alg, key, encryptedKey) => {
      const cryptoKey = await getCryptoKey(key, alg, "unwrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, cryptoKey, "AES-KW", ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
    };
  }
});

// node_modules/jose/dist/browser/runtime/ecdhes.js
async function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
  if (!isCryptoKey(publicKey)) {
    throw new TypeError(invalid_key_input_default(publicKey, ...types));
  }
  checkEncCryptoKey(publicKey, "ECDH");
  if (!isCryptoKey(privateKey)) {
    throw new TypeError(invalid_key_input_default(privateKey, ...types));
  }
  checkEncCryptoKey(privateKey, "ECDH", "deriveBits");
  const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));
  let length;
  if (publicKey.algorithm.name === "X25519") {
    length = 256;
  } else if (publicKey.algorithm.name === "X448") {
    length = 448;
  } else {
    length = Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3;
  }
  const sharedSecret = new Uint8Array(await webcrypto_default.subtle.deriveBits({
    name: publicKey.algorithm.name,
    public: publicKey
  }, privateKey, length));
  return concatKdf(sharedSecret, keyLength, value);
}
async function generateEpk(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return webcrypto_default.subtle.generateKey(key.algorithm, true, ["deriveBits"]);
}
function ecdhAllowed(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return ["P-256", "P-384", "P-521"].includes(key.algorithm.namedCurve) || key.algorithm.name === "X25519" || key.algorithm.name === "X448";
}
var init_ecdhes = __esm({
  "node_modules/jose/dist/browser/runtime/ecdhes.js"() {
    init_buffer_utils();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/lib/check_p2s.js
function checkP2s(p2s2) {
  if (!(p2s2 instanceof Uint8Array) || p2s2.length < 8) {
    throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets");
  }
}
var init_check_p2s = __esm({
  "node_modules/jose/dist/browser/lib/check_p2s.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/pbes2kw.js
function getCryptoKey2(key, alg) {
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "PBKDF2", false, ["deriveBits"]);
  }
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, "deriveBits", "deriveKey");
    return key;
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
async function deriveKey2(p2s2, alg, p2c, key) {
  checkP2s(p2s2);
  const salt = p2s(alg, p2s2);
  const keylen = parseInt(alg.slice(13, 16), 10);
  const subtleAlg = {
    hash: `SHA-${alg.slice(8, 11)}`,
    iterations: p2c,
    name: "PBKDF2",
    salt
  };
  const wrapAlg = {
    length: keylen,
    name: "AES-KW"
  };
  const cryptoKey = await getCryptoKey2(key, alg);
  if (cryptoKey.usages.includes("deriveBits")) {
    return new Uint8Array(await webcrypto_default.subtle.deriveBits(subtleAlg, cryptoKey, keylen));
  }
  if (cryptoKey.usages.includes("deriveKey")) {
    return webcrypto_default.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ["wrapKey", "unwrapKey"]);
  }
  throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');
}
var encrypt, decrypt2;
var init_pbes2kw = __esm({
  "node_modules/jose/dist/browser/runtime/pbes2kw.js"() {
    init_random();
    init_buffer_utils();
    init_base64url();
    init_aeskw();
    init_check_p2s();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    encrypt = async (alg, key, cek, p2c = 2048, p2s2 = random_default(new Uint8Array(16))) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      const encryptedKey = await wrap(alg.slice(-6), derived, cek);
      return { encryptedKey, p2c, p2s: encode(p2s2) };
    };
    decrypt2 = async (alg, key, encryptedKey, p2c, p2s2) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      return unwrap(alg.slice(-6), derived, encryptedKey);
    };
  }
});

// node_modules/jose/dist/browser/runtime/subtle_rsaes.js
function subtleRsaEs(alg) {
  switch (alg) {
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      return "RSA-OAEP";
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_rsaes = __esm({
  "node_modules/jose/dist/browser/runtime/subtle_rsaes.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default;
var init_check_key_length = __esm({
  "node_modules/jose/dist/browser/runtime/check_key_length.js"() {
    check_key_length_default = (alg, key) => {
      if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/rsaes.js
var encrypt2, decrypt3;
var init_rsaes = __esm({
  "node_modules/jose/dist/browser/runtime/rsaes.js"() {
    init_subtle_rsaes();
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_check_key_length();
    init_invalid_key_input();
    init_is_key_like();
    encrypt2 = async (alg, key, cek) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      checkEncCryptoKey(key, alg, "encrypt", "wrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("encrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.encrypt(subtleRsaEs(alg), key, cek));
      }
      if (key.usages.includes("wrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, key, subtleRsaEs(alg)));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation');
    };
    decrypt3 = async (alg, key, encryptedKey) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      checkEncCryptoKey(key, alg, "decrypt", "unwrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("decrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.decrypt(subtleRsaEs(alg), key, encryptedKey));
      }
      if (key.usages.includes("unwrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, key, subtleRsaEs(alg), ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation');
    };
  }
});

// node_modules/jose/dist/browser/lib/cek.js
function bitLength2(alg) {
  switch (alg) {
    case "A128GCM":
      return 128;
    case "A192GCM":
      return 192;
    case "A256GCM":
    case "A128CBC-HS256":
      return 256;
    case "A192CBC-HS384":
      return 384;
    case "A256CBC-HS512":
      return 512;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var cek_default;
var init_cek = __esm({
  "node_modules/jose/dist/browser/lib/cek.js"() {
    init_errors();
    init_random();
    cek_default = (alg) => random_default(new Uint8Array(bitLength2(alg) >> 3));
  }
});

// node_modules/jose/dist/browser/lib/format_pem.js
var format_pem_default;
var init_format_pem = __esm({
  "node_modules/jose/dist/browser/lib/format_pem.js"() {
    format_pem_default = (b64, descriptor) => {
      const newlined = (b64.match(/.{1,64}/g) || []).join("\n");
      return `-----BEGIN ${descriptor}-----
${newlined}
-----END ${descriptor}-----`;
    };
  }
});

// node_modules/jose/dist/browser/runtime/asn1.js
function getElement(seq) {
  const result = [];
  let next = 0;
  while (next < seq.length) {
    const nextPart = parseElement(seq.subarray(next));
    result.push(nextPart);
    next += nextPart.byteLength;
  }
  return result;
}
function parseElement(bytes) {
  let position = 0;
  let tag = bytes[0] & 31;
  position++;
  if (tag === 31) {
    tag = 0;
    while (bytes[position] >= 128) {
      tag = tag * 128 + bytes[position] - 128;
      position++;
    }
    tag = tag * 128 + bytes[position] - 128;
    position++;
  }
  let length = 0;
  if (bytes[position] < 128) {
    length = bytes[position];
    position++;
  } else if (length === 128) {
    length = 0;
    while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {
      if (length > bytes.byteLength) {
        throw new TypeError("invalid indefinite form length");
      }
      length++;
    }
    const byteLength2 = position + length + 2;
    return {
      byteLength: byteLength2,
      contents: bytes.subarray(position, position + length),
      raw: bytes.subarray(0, byteLength2)
    };
  } else {
    const numberOfDigits = bytes[position] & 127;
    position++;
    length = 0;
    for (let i = 0; i < numberOfDigits; i++) {
      length = length * 256 + bytes[position];
      position++;
    }
  }
  const byteLength = position + length;
  return {
    byteLength,
    contents: bytes.subarray(position, byteLength),
    raw: bytes.subarray(0, byteLength)
  };
}
function spkiFromX509(buf) {
  const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);
  return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 160 ? 6 : 5].raw);
}
function getSPKI(x509) {
  const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, "");
  const raw = decodeBase64(pem);
  return format_pem_default(spkiFromX509(raw), "PUBLIC KEY");
}
var genericExport, toSPKI, toPKCS8, findOid, getNamedCurve2, genericImport, fromPKCS8, fromSPKI, fromX509;
var init_asn1 = __esm({
  "node_modules/jose/dist/browser/runtime/asn1.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_format_pem();
    init_errors();
    init_is_key_like();
    genericExport = async (keyType, keyFormat, key) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      if (!key.extractable) {
        throw new TypeError("CryptoKey is not extractable");
      }
      if (key.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
      }
      return format_pem_default(encodeBase64(new Uint8Array(await webcrypto_default.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);
    };
    toSPKI = (key) => {
      return genericExport("public", "spki", key);
    };
    toPKCS8 = (key) => {
      return genericExport("private", "pkcs8", key);
    };
    findOid = (keyData, oid, from = 0) => {
      if (from === 0) {
        oid.unshift(oid.length);
        oid.unshift(6);
      }
      const i = keyData.indexOf(oid[0], from);
      if (i === -1)
        return false;
      const sub = keyData.subarray(i, i + oid.length);
      if (sub.length !== oid.length)
        return false;
      return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);
    };
    getNamedCurve2 = (keyData) => {
      switch (true) {
        case findOid(keyData, [42, 134, 72, 206, 61, 3, 1, 7]):
          return "P-256";
        case findOid(keyData, [43, 129, 4, 0, 34]):
          return "P-384";
        case findOid(keyData, [43, 129, 4, 0, 35]):
          return "P-521";
        case findOid(keyData, [43, 101, 110]):
          return "X25519";
        case findOid(keyData, [43, 101, 111]):
          return "X448";
        case findOid(keyData, [43, 101, 112]):
          return "Ed25519";
        case findOid(keyData, [43, 101, 113]):
          return "Ed448";
        default:
          throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type");
      }
    };
    genericImport = async (replace, keyFormat, pem, alg, options) => {
      let algorithm;
      let keyUsages;
      const keyData = new Uint8Array(atob(pem.replace(replace, "")).split("").map((c) => c.charCodeAt(0)));
      const isPublic = keyFormat === "spki";
      switch (alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
          };
          keyUsages = isPublic ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
          break;
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW": {
          const namedCurve = getNamedCurve2(keyData);
          algorithm = namedCurve.startsWith("P-") ? { name: "ECDH", namedCurve } : { name: namedCurve };
          keyUsages = isPublic ? [] : ["deriveBits"];
          break;
        }
        case "EdDSA":
          algorithm = { name: getNamedCurve2(keyData) };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
      }
      return webcrypto_default.subtle.importKey(keyFormat, keyData, algorithm, (options == null ? void 0 : options.extractable) ?? false, keyUsages);
    };
    fromPKCS8 = (pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "pkcs8", pem, alg, options);
    };
    fromSPKI = (pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, "spki", pem, alg, options);
    };
    fromX509 = (pem, alg, options) => {
      let spki;
      try {
        spki = getSPKI(pem);
      } catch (cause) {
        throw new TypeError("Failed to parse the X.509 certificate", { cause });
      }
      return fromSPKI(spki, alg, options);
    };
  }
});

// node_modules/jose/dist/browser/runtime/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var parse, jwk_to_key_default;
var init_jwk_to_key = __esm({
  "node_modules/jose/dist/browser/runtime/jwk_to_key.js"() {
    init_webcrypto();
    init_errors();
    parse = async (jwk) => {
      if (!jwk.alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
      }
      const { algorithm, keyUsages } = subtleMapping(jwk);
      const rest = [
        algorithm,
        jwk.ext ?? false,
        jwk.key_ops ?? keyUsages
      ];
      const keyData = { ...jwk };
      delete keyData.alg;
      delete keyData.use;
      return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
    };
    jwk_to_key_default = parse;
  }
});

// node_modules/jose/dist/browser/key/import.js
async function importSPKI(spki, alg, options) {
  if (typeof spki !== "string" || spki.indexOf("-----BEGIN PUBLIC KEY-----") !== 0) {
    throw new TypeError('"spki" must be SPKI formatted string');
  }
  return fromSPKI(spki, alg, options);
}
async function importX509(x509, alg, options) {
  if (typeof x509 !== "string" || x509.indexOf("-----BEGIN CERTIFICATE-----") !== 0) {
    throw new TypeError('"x509" must be X.509 formatted string');
  }
  return fromX509(x509, alg, options);
}
async function importPKCS8(pkcs8, alg, options) {
  if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
    throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  }
  return fromPKCS8(pkcs8, alg, options);
}
async function importJWK(jwk, alg) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      return decode(jwk.k);
    case "RSA":
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
var init_import = __esm({
  "node_modules/jose/dist/browser/key/import.js"() {
    init_base64url();
    init_asn1();
    init_jwk_to_key();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck, asymmetricTypeCheck, checkKeyType, check_key_type_default;
var init_check_key_type = __esm({
  "node_modules/jose/dist/browser/lib/check_key_type.js"() {
    init_invalid_key_input();
    init_is_key_like();
    symmetricTypeCheck = (alg, key) => {
      if (key instanceof Uint8Array)
        return;
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    asymmetricTypeCheck = (alg, key, usage) => {
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types));
      }
      if (key.type === "secret") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    };
    checkKeyType = (alg, key, usage) => {
      const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
        symmetricTypeCheck(alg, key);
      } else {
        asymmetricTypeCheck(alg, key, usage);
      }
    };
    check_key_type_default = checkKeyType;
  }
});

// node_modules/jose/dist/browser/runtime/encrypt.js
async function cbcEncrypt(enc, plaintext, cek, iv, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["encrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const ciphertext = new Uint8Array(await webcrypto_default.subtle.encrypt({
    iv,
    name: "AES-CBC"
  }, encKey, plaintext));
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const tag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  return { ciphertext, tag };
}
async function gcmEncrypt(enc, plaintext, cek, iv, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["encrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "encrypt");
    encKey = cek;
  }
  const encrypted = new Uint8Array(await webcrypto_default.subtle.encrypt({
    additionalData: aad,
    iv,
    name: "AES-GCM",
    tagLength: 128
  }, encKey, plaintext));
  const tag = encrypted.slice(-16);
  const ciphertext = encrypted.slice(0, -16);
  return { ciphertext, tag };
}
var encrypt3, encrypt_default;
var init_encrypt = __esm({
  "node_modules/jose/dist/browser/runtime/encrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_errors();
    init_is_key_like();
    encrypt3 = async (enc, plaintext, cek, iv, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcEncrypt(enc, plaintext, cek, iv, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmEncrypt(enc, plaintext, cek, iv, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    encrypt_default = encrypt3;
  }
});

// node_modules/jose/dist/browser/lib/aesgcmkw.js
async function wrap2(alg, key, cek, iv) {
  const jweAlgorithm = alg.slice(0, 7);
  iv || (iv = iv_default(jweAlgorithm));
  const { ciphertext: encryptedKey, tag } = await encrypt_default(jweAlgorithm, cek, key, iv, new Uint8Array(0));
  return { encryptedKey, iv: encode(iv), tag: encode(tag) };
}
async function unwrap2(alg, key, encryptedKey, iv, tag) {
  const jweAlgorithm = alg.slice(0, 7);
  return decrypt_default(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
}
var init_aesgcmkw = __esm({
  "node_modules/jose/dist/browser/lib/aesgcmkw.js"() {
    init_encrypt();
    init_decrypt();
    init_iv();
    init_base64url();
  }
});

// node_modules/jose/dist/browser/lib/decrypt_key_management.js
async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
  check_key_type_default(alg, key, "decrypt");
  switch (alg) {
    case "dir": {
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
      return key;
    }
    case "ECDH-ES":
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!isObject(joseHeader.epk))
        throw new JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
      if (!ecdhAllowed(key))
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      const epk = await importJWK(joseHeader.epk, alg);
      let partyUInfo;
      let partyVInfo;
      if (joseHeader.apu !== void 0) {
        if (typeof joseHeader.apu !== "string")
          throw new JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
        try {
          partyUInfo = decode(joseHeader.apu);
        } catch {
          throw new JWEInvalid("Failed to base64url decode the apu");
        }
      }
      if (joseHeader.apv !== void 0) {
        if (typeof joseHeader.apv !== "string")
          throw new JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
        try {
          partyVInfo = decode(joseHeader.apv);
        } catch {
          throw new JWEInvalid("Failed to base64url decode the apv");
        }
      }
      const sharedSecret = await deriveKey(epk, key, alg === "ECDH-ES" ? joseHeader.enc : alg, alg === "ECDH-ES" ? bitLength2(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
      if (alg === "ECDH-ES")
        return sharedSecret;
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg.slice(-6), sharedSecret, encryptedKey);
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return decrypt3(alg, key, encryptedKey);
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.p2c !== "number")
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
      const p2cLimit = (options == null ? void 0 : options.maxPBES2Count) || 1e4;
      if (joseHeader.p2c > p2cLimit)
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
      if (typeof joseHeader.p2s !== "string")
        throw new JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
      let p2s2;
      try {
        p2s2 = decode(joseHeader.p2s);
      } catch {
        throw new JWEInvalid("Failed to base64url decode the p2s");
      }
      return decrypt2(alg, key, encryptedKey, joseHeader.p2c, p2s2);
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg, key, encryptedKey);
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.iv !== "string")
        throw new JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
      if (typeof joseHeader.tag !== "string")
        throw new JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
      let iv;
      try {
        iv = decode(joseHeader.iv);
      } catch {
        throw new JWEInvalid("Failed to base64url decode the iv");
      }
      let tag;
      try {
        tag = decode(joseHeader.tag);
      } catch {
        throw new JWEInvalid("Failed to base64url decode the tag");
      }
      return unwrap2(alg, key, encryptedKey, iv, tag);
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
}
var decrypt_key_management_default;
var init_decrypt_key_management = __esm({
  "node_modules/jose/dist/browser/lib/decrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_errors();
    init_cek();
    init_import();
    init_check_key_type();
    init_is_object();
    init_aesgcmkw();
    decrypt_key_management_default = decryptKeyManagement;
  }
});

// node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default;
var init_validate_crit = __esm({
  "node_modules/jose/dist/browser/lib/validate_crit.js"() {
    init_errors();
    validate_crit_default = validateCrit;
  }
});

// node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms, validate_algorithms_default;
var init_validate_algorithms = __esm({
  "node_modules/jose/dist/browser/lib/validate_algorithms.js"() {
    validateAlgorithms = (option, algorithms) => {
      if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
        return void 0;
      }
      return new Set(algorithms);
    };
    validate_algorithms_default = validateAlgorithms;
  }
});

// node_modules/jose/dist/browser/jwe/flattened/decrypt.js
async function flattenedDecrypt(jwe, key, options) {
  if (!isObject(jwe)) {
    throw new JWEInvalid("Flattened JWE must be an object");
  }
  if (jwe.protected === void 0 && jwe.header === void 0 && jwe.unprotected === void 0) {
    throw new JWEInvalid("JOSE Header missing");
  }
  if (jwe.iv !== void 0 && typeof jwe.iv !== "string") {
    throw new JWEInvalid("JWE Initialization Vector incorrect type");
  }
  if (typeof jwe.ciphertext !== "string") {
    throw new JWEInvalid("JWE Ciphertext missing or incorrect type");
  }
  if (jwe.tag !== void 0 && typeof jwe.tag !== "string") {
    throw new JWEInvalid("JWE Authentication Tag incorrect type");
  }
  if (jwe.protected !== void 0 && typeof jwe.protected !== "string") {
    throw new JWEInvalid("JWE Protected Header incorrect type");
  }
  if (jwe.encrypted_key !== void 0 && typeof jwe.encrypted_key !== "string") {
    throw new JWEInvalid("JWE Encrypted Key incorrect type");
  }
  if (jwe.aad !== void 0 && typeof jwe.aad !== "string") {
    throw new JWEInvalid("JWE AAD incorrect type");
  }
  if (jwe.header !== void 0 && !isObject(jwe.header)) {
    throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");
  }
  if (jwe.unprotected !== void 0 && !isObject(jwe.unprotected)) {
    throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
  }
  let parsedProt;
  if (jwe.protected) {
    try {
      const protectedHeader2 = decode(jwe.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader2));
    } catch {
      throw new JWEInvalid("JWE Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jwe.header, jwe.unprotected)) {
    throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jwe.header,
    ...jwe.unprotected
  };
  validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options == null ? void 0 : options.crit, parsedProt, joseHeader);
  if (joseHeader.zip !== void 0) {
    throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');
  }
  const { alg, enc } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
  }
  if (typeof enc !== "string" || !enc) {
    throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
  }
  const keyManagementAlgorithms = options && validate_algorithms_default("keyManagementAlgorithms", options.keyManagementAlgorithms);
  const contentEncryptionAlgorithms = options && validate_algorithms_default("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
  if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg) || !keyManagementAlgorithms && alg.startsWith("PBES2")) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
    throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter value not allowed');
  }
  let encryptedKey;
  if (jwe.encrypted_key !== void 0) {
    try {
      encryptedKey = decode(jwe.encrypted_key);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the encrypted_key");
    }
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jwe);
    resolvedKey = true;
  }
  let cek;
  try {
    cek = await decrypt_key_management_default(alg, key, encryptedKey, joseHeader, options);
  } catch (err) {
    if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {
      throw err;
    }
    cek = cek_default(enc);
  }
  let iv;
  let tag;
  if (jwe.iv !== void 0) {
    try {
      iv = decode(jwe.iv);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the iv");
    }
  }
  if (jwe.tag !== void 0) {
    try {
      tag = decode(jwe.tag);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the tag");
    }
  }
  const protectedHeader = encoder.encode(jwe.protected ?? "");
  let additionalData;
  if (jwe.aad !== void 0) {
    additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(jwe.aad));
  } else {
    additionalData = protectedHeader;
  }
  let ciphertext;
  try {
    ciphertext = decode(jwe.ciphertext);
  } catch {
    throw new JWEInvalid("Failed to base64url decode the ciphertext");
  }
  const plaintext = await decrypt_default(enc, cek, ciphertext, iv, tag, additionalData);
  const result = { plaintext };
  if (jwe.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jwe.aad !== void 0) {
    try {
      result.additionalAuthenticatedData = decode(jwe.aad);
    } catch {
      throw new JWEInvalid("Failed to base64url decode the aad");
    }
  }
  if (jwe.unprotected !== void 0) {
    result.sharedUnprotectedHeader = jwe.unprotected;
  }
  if (jwe.header !== void 0) {
    result.unprotectedHeader = jwe.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_decrypt2 = __esm({
  "node_modules/jose/dist/browser/jwe/flattened/decrypt.js"() {
    init_base64url();
    init_decrypt();
    init_errors();
    init_is_disjoint();
    init_is_object();
    init_decrypt_key_management();
    init_buffer_utils();
    init_cek();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// node_modules/jose/dist/browser/jwe/compact/decrypt.js
async function compactDecrypt(jwe, key, options) {
  if (jwe instanceof Uint8Array) {
    jwe = decoder.decode(jwe);
  }
  if (typeof jwe !== "string") {
    throw new JWEInvalid("Compact JWE must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length } = jwe.split(".");
  if (length !== 5) {
    throw new JWEInvalid("Invalid Compact JWE");
  }
  const decrypted = await flattenedDecrypt({
    ciphertext,
    iv: iv || void 0,
    protected: protectedHeader,
    tag: tag || void 0,
    encrypted_key: encryptedKey || void 0
  }, key, options);
  const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt3 = __esm({
  "node_modules/jose/dist/browser/jwe/compact/decrypt.js"() {
    init_decrypt2();
    init_errors();
    init_buffer_utils();
  }
});

// node_modules/jose/dist/browser/jwe/general/decrypt.js
async function generalDecrypt(jwe, key, options) {
  if (!isObject(jwe)) {
    throw new JWEInvalid("General JWE must be an object");
  }
  if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject)) {
    throw new JWEInvalid("JWE Recipients missing or incorrect type");
  }
  if (!jwe.recipients.length) {
    throw new JWEInvalid("JWE Recipients has no members");
  }
  for (const recipient of jwe.recipients) {
    try {
      return await flattenedDecrypt({
        aad: jwe.aad,
        ciphertext: jwe.ciphertext,
        encrypted_key: recipient.encrypted_key,
        header: recipient.header,
        iv: jwe.iv,
        protected: jwe.protected,
        tag: jwe.tag,
        unprotected: jwe.unprotected
      }, key, options);
    } catch {
    }
  }
  throw new JWEDecryptionFailed();
}
var init_decrypt4 = __esm({
  "node_modules/jose/dist/browser/jwe/general/decrypt.js"() {
    init_decrypt2();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/runtime/key_to_jwk.js
var keyToJWK, key_to_jwk_default;
var init_key_to_jwk = __esm({
  "node_modules/jose/dist/browser/runtime/key_to_jwk.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_is_key_like();
    keyToJWK = async (key) => {
      if (key instanceof Uint8Array) {
        return {
          kty: "oct",
          k: encode(key)
        };
      }
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
      }
      if (!key.extractable) {
        throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");
      }
      const { ext, key_ops, alg, use, ...jwk } = await webcrypto_default.subtle.exportKey("jwk", key);
      return jwk;
    };
    key_to_jwk_default = keyToJWK;
  }
});

// node_modules/jose/dist/browser/key/export.js
async function exportSPKI(key) {
  return toSPKI(key);
}
async function exportPKCS8(key) {
  return toPKCS8(key);
}
async function exportJWK(key) {
  return key_to_jwk_default(key);
}
var init_export = __esm({
  "node_modules/jose/dist/browser/key/export.js"() {
    init_asn1();
    init_asn1();
    init_key_to_jwk();
  }
});

// node_modules/jose/dist/browser/lib/encrypt_key_management.js
async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
  let encryptedKey;
  let parameters;
  let cek;
  check_key_type_default(alg, key, "encrypt");
  switch (alg) {
    case "dir": {
      cek = key;
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!ecdhAllowed(key)) {
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      }
      const { apu, apv } = providedParameters;
      let { epk: ephemeralKey } = providedParameters;
      ephemeralKey || (ephemeralKey = (await generateEpk(key)).privateKey);
      const { x, y, crv, kty } = await exportJWK(ephemeralKey);
      const sharedSecret = await deriveKey(key, ephemeralKey, alg === "ECDH-ES" ? enc : alg, alg === "ECDH-ES" ? bitLength2(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
      parameters = { epk: { x, crv, kty } };
      if (kty === "EC")
        parameters.epk.y = y;
      if (apu)
        parameters.apu = encode(apu);
      if (apv)
        parameters.apv = encode(apv);
      if (alg === "ECDH-ES") {
        cek = sharedSecret;
        break;
      }
      cek = providedCek || cek_default(enc);
      const kwAlg = alg.slice(-6);
      encryptedKey = await wrap(kwAlg, sharedSecret, cek);
      break;
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await encrypt2(alg, key, cek);
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      cek = providedCek || cek_default(enc);
      const { p2c, p2s: p2s2 } = providedParameters;
      ({ encryptedKey, ...parameters } = await encrypt(alg, key, cek, p2c, p2s2));
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await wrap(alg, key, cek);
      break;
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      cek = providedCek || cek_default(enc);
      const { iv } = providedParameters;
      ({ encryptedKey, ...parameters } = await wrap2(alg, key, cek, iv));
      break;
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
  return { cek, encryptedKey, parameters };
}
var encrypt_key_management_default;
var init_encrypt_key_management = __esm({
  "node_modules/jose/dist/browser/lib/encrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_cek();
    init_errors();
    init_export();
    init_check_key_type();
    init_aesgcmkw();
    encrypt_key_management_default = encryptKeyManagement;
  }
});

// node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var unprotected, FlattenedEncrypt;
var init_encrypt2 = __esm({
  "node_modules/jose/dist/browser/jwe/flattened/encrypt.js"() {
    init_base64url();
    init_encrypt();
    init_iv();
    init_encrypt_key_management();
    init_errors();
    init_is_disjoint();
    init_buffer_utils();
    init_validate_crit();
    unprotected = Symbol();
    FlattenedEncrypt = class {
      constructor(plaintext) {
        if (!(plaintext instanceof Uint8Array)) {
          throw new TypeError("plaintext must be an instance of Uint8Array");
        }
        this._plaintext = plaintext;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
          throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
          throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader,
          ...this._sharedUnprotectedHeader
        };
        validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options == null ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== void 0) {
          throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== "string" || !enc) {
          throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (alg === "dir") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
          }
        } else if (alg === "ECDH-ES") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
          }
        }
        let cek;
        {
          let parameters;
          ({ cek, encryptedKey, parameters } = await encrypt_key_management_default(alg, enc, key, this._cek, this._keyManagementParameters));
          if (parameters) {
            if (options && unprotected in options) {
              if (!this._unprotectedHeader) {
                this.setUnprotectedHeader(parameters);
              } else {
                this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
              }
            } else {
              if (!this._protectedHeader) {
                this.setProtectedHeader(parameters);
              } else {
                this._protectedHeader = { ...this._protectedHeader, ...parameters };
              }
            }
          }
        }
        this._iv || (this._iv = iv_default(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        if (this._aad) {
          aadMember = encode(this._aad);
          additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(aadMember));
        } else {
          additionalData = protectedHeader;
        }
        const { ciphertext, tag } = await encrypt_default(enc, this._plaintext, cek, this._iv, additionalData);
        const jwe = {
          ciphertext: encode(ciphertext),
          iv: encode(this._iv),
          tag: encode(tag)
        };
        if (encryptedKey) {
          jwe.encrypted_key = encode(encryptedKey);
        }
        if (aadMember) {
          jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
          jwe.protected = decoder.decode(protectedHeader);
        }
        if (this._sharedUnprotectedHeader) {
          jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
          jwe.header = this._unprotectedHeader;
        }
        return jwe;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwe/general/encrypt.js
var IndividualRecipient, GeneralEncrypt;
var init_encrypt3 = __esm({
  "node_modules/jose/dist/browser/jwe/general/encrypt.js"() {
    init_encrypt2();
    init_errors();
    init_cek();
    init_is_disjoint();
    init_encrypt_key_management();
    init_base64url();
    init_validate_crit();
    IndividualRecipient = class {
      constructor(enc, key, options) {
        this.parent = enc;
        this.key = key;
        this.options = options;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addRecipient(...args) {
        return this.parent.addRecipient(...args);
      }
      encrypt(...args) {
        return this.parent.encrypt(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralEncrypt = class {
      constructor(plaintext) {
        this._recipients = [];
        this._plaintext = plaintext;
      }
      addRecipient(key, options) {
        const recipient = new IndividualRecipient(this, key, { crit: options == null ? void 0 : options.crit });
        this._recipients.push(recipient);
        return recipient;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      async encrypt() {
        var _a2, _b2, _c;
        if (!this._recipients.length) {
          throw new JWEInvalid("at least one recipient must be added");
        }
        if (this._recipients.length === 1) {
          const [recipient] = this._recipients;
          const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options });
          const jwe2 = {
            ciphertext: flattened.ciphertext,
            iv: flattened.iv,
            recipients: [{}],
            tag: flattened.tag
          };
          if (flattened.aad)
            jwe2.aad = flattened.aad;
          if (flattened.protected)
            jwe2.protected = flattened.protected;
          if (flattened.unprotected)
            jwe2.unprotected = flattened.unprotected;
          if (flattened.encrypted_key)
            jwe2.recipients[0].encrypted_key = flattened.encrypted_key;
          if (flattened.header)
            jwe2.recipients[0].header = flattened.header;
          return jwe2;
        }
        let enc;
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
            throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
          }
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const { alg } = joseHeader;
          if (typeof alg !== "string" || !alg) {
            throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
          }
          if (alg === "dir" || alg === "ECDH-ES") {
            throw new JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
          }
          if (typeof joseHeader.enc !== "string" || !joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
          }
          if (!enc) {
            enc = joseHeader.enc;
          } else if (enc !== joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
          }
          validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
          if (joseHeader.zip !== void 0) {
            throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported.');
          }
        }
        const cek = cek_default(enc);
        const jwe = {
          ciphertext: "",
          iv: "",
          recipients: [],
          tag: ""
        };
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          const target = {};
          jwe.recipients.push(target);
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const p2c = joseHeader.alg.startsWith("PBES2") ? 2048 + i : void 0;
          if (i === 0) {
            const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({ p2c }).encrypt(recipient.key, {
              ...recipient.options,
              [unprotected]: true
            });
            jwe.ciphertext = flattened.ciphertext;
            jwe.iv = flattened.iv;
            jwe.tag = flattened.tag;
            if (flattened.aad)
              jwe.aad = flattened.aad;
            if (flattened.protected)
              jwe.protected = flattened.protected;
            if (flattened.unprotected)
              jwe.unprotected = flattened.unprotected;
            target.encrypted_key = flattened.encrypted_key;
            if (flattened.header)
              target.header = flattened.header;
            continue;
          }
          const { encryptedKey, parameters } = await encrypt_key_management_default(((_a2 = recipient.unprotectedHeader) == null ? void 0 : _a2.alg) || ((_b2 = this._protectedHeader) == null ? void 0 : _b2.alg) || ((_c = this._unprotectedHeader) == null ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });
          target.encrypted_key = encode(encryptedKey);
          if (recipient.unprotectedHeader || parameters)
            target.header = { ...recipient.unprotectedHeader, ...parameters };
        }
        return jwe;
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_dsa = __esm({
  "node_modules/jose/dist/browser/runtime/subtle_dsa.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey3(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
var init_get_sign_verify_key = __esm({
  "node_modules/jose/dist/browser/runtime/get_sign_verify_key.js"() {
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/runtime/verify.js
var verify, verify_default;
var init_verify = __esm({
  "node_modules/jose/dist/browser/runtime/verify.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    verify = async (alg, key, signature, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "verify");
      check_key_length_default(alg, cryptoKey);
      const algorithm = subtleDsa(alg, cryptoKey.algorithm);
      try {
        return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
      } catch {
        return false;
      }
    };
    verify_default = verify;
  }
});

// node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options == null ? void 0 : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder.encode(jws.protected ?? ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_verify2 = __esm({
  "node_modules/jose/dist/browser/jws/flattened/verify.js"() {
    init_base64url();
    init_verify();
    init_errors();
    init_buffer_utils();
    init_is_disjoint();
    init_is_object();
    init_check_key_type();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify3 = __esm({
  "node_modules/jose/dist/browser/jws/compact/verify.js"() {
    init_verify2();
    init_errors();
    init_buffer_utils();
  }
});

// node_modules/jose/dist/browser/jws/general/verify.js
async function generalVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("General JWS must be an object");
  }
  if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject)) {
    throw new JWSInvalid("JWS Signatures missing or incorrect type");
  }
  for (const signature of jws.signatures) {
    try {
      return await flattenedVerify({
        header: signature.header,
        payload: jws.payload,
        protected: signature.protected,
        signature: signature.signature
      }, key, options);
    } catch {
    }
  }
  throw new JWSSignatureVerificationFailed();
}
var init_verify4 = __esm({
  "node_modules/jose/dist/browser/jws/general/verify.js"() {
    init_verify2();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/lib/epoch.js
var epoch_default;
var init_epoch = __esm({
  "node_modules/jose/dist/browser/lib/epoch.js"() {
    epoch_default = (date) => Math.floor(date.getTime() / 1e3);
  }
});

// node_modules/jose/dist/browser/lib/secs.js
var minute, hour, day, week, year, REGEX, secs_default;
var init_secs = __esm({
  "node_modules/jose/dist/browser/lib/secs.js"() {
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    week = day * 7;
    year = day * 365.25;
    REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
    secs_default = (str) => {
      const matched = REGEX.exec(str);
      if (!matched || matched[4] && matched[1]) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[2]);
      const unit = matched[3].toLowerCase();
      let numericDate;
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          numericDate = Math.round(value);
          break;
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          numericDate = Math.round(value * minute);
          break;
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          numericDate = Math.round(value * hour);
          break;
        case "day":
        case "days":
        case "d":
          numericDate = Math.round(value * day);
          break;
        case "week":
        case "weeks":
        case "w":
          numericDate = Math.round(value * week);
          break;
        default:
          numericDate = Math.round(value * year);
          break;
      }
      if (matched[1] === "-" || matched[4] === "ago") {
        return -numericDate;
      }
      return numericDate;
    };
  }
});

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp, checkAudiencePresence, jwt_claims_set_default;
var init_jwt_claims_set = __esm({
  "node_modules/jose/dist/browser/lib/jwt_claims_set.js"() {
    init_errors();
    init_buffer_utils();
    init_epoch();
    init_secs();
    init_is_object();
    normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
    checkAudiencePresence = (audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    };
    jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
      const { typ } = options;
      if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
      }
      let payload;
      try {
        payload = JSON.parse(decoder.decode(encodedPayload));
      } catch {
      }
      if (!isObject(payload)) {
        throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
      }
      const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
      const presenceCheck = [...requiredClaims];
      if (maxTokenAge !== void 0)
        presenceCheck.push("iat");
      if (audience !== void 0)
        presenceCheck.push("aud");
      if (subject !== void 0)
        presenceCheck.push("sub");
      if (issuer !== void 0)
        presenceCheck.push("iss");
      for (const claim of new Set(presenceCheck.reverse())) {
        if (!(claim in payload)) {
          throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
        }
      }
      if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
      }
      if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
      }
      if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
      }
      let tolerance;
      switch (typeof options.clockTolerance) {
        case "string":
          tolerance = secs_default(options.clockTolerance);
          break;
        case "number":
          tolerance = options.clockTolerance;
          break;
        case "undefined":
          tolerance = 0;
          break;
        default:
          throw new TypeError("Invalid clockTolerance option type");
      }
      const { currentDate } = options;
      const now = epoch_default(currentDate || /* @__PURE__ */ new Date());
      if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
      }
      if (payload.nbf !== void 0) {
        if (typeof payload.nbf !== "number") {
          throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
        }
        if (payload.nbf > now + tolerance) {
          throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
        }
      }
      if (payload.exp !== void 0) {
        if (typeof payload.exp !== "number") {
          throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
        }
        if (payload.exp <= now - tolerance) {
          throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
        }
      }
      if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
        if (age - tolerance > max) {
          throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
          throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
        }
      }
      return payload;
    };
  }
});

// node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a2;
  const verified = await compactVerify(jwt, key, options);
  if (((_a2 = verified.protectedHeader.crit) == null ? void 0 : _a2.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify5 = __esm({
  "node_modules/jose/dist/browser/jwt/verify.js"() {
    init_verify3();
    init_jwt_claims_set();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwt/decrypt.js
async function jwtDecrypt(jwt, key, options) {
  const decrypted = await compactDecrypt(jwt, key, options);
  const payload = jwt_claims_set_default(decrypted.protectedHeader, decrypted.plaintext, options);
  const { protectedHeader } = decrypted;
  if (protectedHeader.iss !== void 0 && protectedHeader.iss !== payload.iss) {
    throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
  }
  if (protectedHeader.sub !== void 0 && protectedHeader.sub !== payload.sub) {
    throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
  }
  if (protectedHeader.aud !== void 0 && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
    throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
  }
  const result = { payload, protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt5 = __esm({
  "node_modules/jose/dist/browser/jwt/decrypt.js"() {
    init_decrypt3();
    init_jwt_claims_set();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwe/compact/encrypt.js
var CompactEncrypt;
var init_encrypt4 = __esm({
  "node_modules/jose/dist/browser/jwe/compact/encrypt.js"() {
    init_encrypt2();
    CompactEncrypt = class {
      constructor(plaintext) {
        this._flattened = new FlattenedEncrypt(plaintext);
      }
      setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
      }
      setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
      }
      async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/sign.js
var sign, sign_default;
var init_sign = __esm({
  "node_modules/jose/dist/browser/runtime/sign.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    sign = async (alg, key, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "sign");
      check_key_length_default(alg, cryptoKey);
      const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
      return new Uint8Array(signature);
    };
    sign_default = sign;
  }
});

// node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign;
var init_sign2 = __esm({
  "node_modules/jose/dist/browser/jws/flattened/sign.js"() {
    init_base64url();
    init_sign();
    init_is_disjoint();
    init_errors();
    init_buffer_utils();
    init_check_key_type();
    init_validate_crit();
    FlattenedSign = class {
      constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
          throw new TypeError("payload must be an instance of Uint8Array");
        }
        this._payload = payload;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
          throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
          throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader
        };
        const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options == null ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has("b64")) {
          b64 = this._protectedHeader.b64;
          if (typeof b64 !== "boolean") {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
        }
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        check_key_type_default(alg, key, "sign");
        let payload = this._payload;
        if (b64) {
          payload = encoder.encode(encode(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        const data = concat(protectedHeader, encoder.encode("."), payload);
        const signature = await sign_default(alg, key, data);
        const jws = {
          signature: encode(signature),
          payload: ""
        };
        if (b64) {
          jws.payload = decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
          jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
          jws.protected = decoder.decode(protectedHeader);
        }
        return jws;
      }
    };
  }
});

// node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign;
var init_sign3 = __esm({
  "node_modules/jose/dist/browser/jws/compact/sign.js"() {
    init_sign2();
    CompactSign = class {
      constructor(payload) {
        this._flattened = new FlattenedSign(payload);
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === void 0) {
          throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
      }
    };
  }
});

// node_modules/jose/dist/browser/jws/general/sign.js
var IndividualSignature, GeneralSign;
var init_sign4 = __esm({
  "node_modules/jose/dist/browser/jws/general/sign.js"() {
    init_sign2();
    init_errors();
    IndividualSignature = class {
      constructor(sig, key, options) {
        this.parent = sig;
        this.key = key;
        this.options = options;
      }
      setProtectedHeader(protectedHeader) {
        if (this.protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this.protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addSignature(...args) {
        return this.parent.addSignature(...args);
      }
      sign(...args) {
        return this.parent.sign(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralSign = class {
      constructor(payload) {
        this._signatures = [];
        this._payload = payload;
      }
      addSignature(key, options) {
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
      }
      async sign() {
        if (!this._signatures.length) {
          throw new JWSInvalid("at least one signature must be added");
        }
        const jws = {
          signatures: [],
          payload: ""
        };
        for (let i = 0; i < this._signatures.length; i++) {
          const signature = this._signatures[i];
          const flattened = new FlattenedSign(this._payload);
          flattened.setProtectedHeader(signature.protectedHeader);
          flattened.setUnprotectedHeader(signature.unprotectedHeader);
          const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
          if (i === 0) {
            jws.payload = payload;
          } else if (jws.payload !== payload) {
            throw new JWSInvalid("inconsistent use of JWS Unencoded Payload (RFC7797)");
          }
          jws.signatures.push(rest);
        }
        return jws;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/produce.js
function validateInput(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}
var ProduceJWT;
var init_produce = __esm({
  "node_modules/jose/dist/browser/jwt/produce.js"() {
    init_epoch();
    init_is_object();
    init_secs();
    ProduceJWT = class {
      constructor(payload = {}) {
        if (!isObject(payload)) {
          throw new TypeError("JWT Claims Set MUST be an object");
        }
        this._payload = payload;
      }
      setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
      }
      setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
      }
      setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
      }
      setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
      }
      setNotBefore(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, nbf: validateInput("setNotBefore", input) };
        } else if (input instanceof Date) {
          this._payload = { ...this._payload, nbf: validateInput("setNotBefore", epoch_default(input)) };
        } else {
          this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setExpirationTime(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, exp: validateInput("setExpirationTime", input) };
        } else if (input instanceof Date) {
          this._payload = { ...this._payload, exp: validateInput("setExpirationTime", epoch_default(input)) };
        } else {
          this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setIssuedAt(input) {
        if (typeof input === "undefined") {
          this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
        } else if (input instanceof Date) {
          this._payload = { ...this._payload, iat: validateInput("setIssuedAt", epoch_default(input)) };
        } else if (typeof input === "string") {
          this._payload = {
            ...this._payload,
            iat: validateInput("setIssuedAt", epoch_default(/* @__PURE__ */ new Date()) + secs_default(input))
          };
        } else {
          this._payload = { ...this._payload, iat: validateInput("setIssuedAt", input) };
        }
        return this;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/sign.js
var SignJWT;
var init_sign5 = __esm({
  "node_modules/jose/dist/browser/jwt/sign.js"() {
    init_sign3();
    init_errors();
    init_buffer_utils();
    init_produce();
    SignJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
      }
      async sign(key, options) {
        var _a2;
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a2 = this._protectedHeader) == null ? void 0 : _a2.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
          throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/encrypt.js
var EncryptJWT;
var init_encrypt5 = __esm({
  "node_modules/jose/dist/browser/jwt/encrypt.js"() {
    init_encrypt4();
    init_buffer_utils();
    init_produce();
    EncryptJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
      }
      replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
      }
      replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
      }
      async encrypt(key, options) {
        const enc = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
        }
        if (this._replicateSubjectAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
        }
        if (this._replicateAudienceAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
          enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
          enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
          enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
      }
    };
  }
});

// node_modules/jose/dist/browser/jwk/thumbprint.js
async function calculateJwkThumbprint(jwk, digestAlgorithm) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  digestAlgorithm ?? (digestAlgorithm = "sha256");
  if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
    throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
  }
  let components;
  switch (jwk.kty) {
    case "EC":
      check(jwk.crv, '"crv" (Curve) Parameter');
      check(jwk.x, '"x" (X Coordinate) Parameter');
      check(jwk.y, '"y" (Y Coordinate) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
      break;
    case "OKP":
      check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
      check(jwk.x, '"x" (Public Key) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
      break;
    case "RSA":
      check(jwk.e, '"e" (Exponent) Parameter');
      check(jwk.n, '"n" (Modulus) Parameter');
      components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
      break;
    case "oct":
      check(jwk.k, '"k" (Key Value) Parameter');
      components = { k: jwk.k, kty: jwk.kty };
      break;
    default:
      throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
  }
  const data = encoder.encode(JSON.stringify(components));
  return encode(await digest_default(digestAlgorithm, data));
}
async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
  digestAlgorithm ?? (digestAlgorithm = "sha256");
  const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
  return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
}
var check;
var init_thumbprint = __esm({
  "node_modules/jose/dist/browser/jwk/thumbprint.js"() {
    init_digest();
    init_base64url();
    init_errors();
    init_buffer_utils();
    init_is_object();
    check = (value, description) => {
      if (typeof value !== "string" || !value) {
        throw new JWKInvalid(`${description} missing or invalid`);
      }
    };
  }
});

// node_modules/jose/dist/browser/jwk/embedded.js
async function EmbeddedJWK(protectedHeader, token) {
  const joseHeader = {
    ...protectedHeader,
    ...token == null ? void 0 : token.header
  };
  if (!isObject(joseHeader.jwk)) {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
  }
  const key = await importJWK({ ...joseHeader.jwk, ext: true }, joseHeader.alg);
  if (key instanceof Uint8Array || key.type !== "public") {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
  }
  return key;
}
var init_embedded = __esm({
  "node_modules/jose/dist/browser/jwk/embedded.js"() {
    init_import();
    init_is_object();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwks/local.js
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject(key);
}
function clone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
async function importWithAlgCache(cache, jwk, alg) {
  const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
  if (cached[alg] === void 0) {
    const key = await importJWK({ ...jwk, ext: true }, alg);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg] = key;
  }
  return cached[alg];
}
function createLocalJWKSet(jwks) {
  const set = new LocalJWKSet(jwks);
  return async (protectedHeader, token) => set.getKey(protectedHeader, token);
}
var LocalJWKSet;
var init_local = __esm({
  "node_modules/jose/dist/browser/jwks/local.js"() {
    init_import();
    init_errors();
    init_is_object();
    LocalJWKSet = class {
      constructor(jwks) {
        this._cached = /* @__PURE__ */ new WeakMap();
        if (!isJWKSLike(jwks)) {
          throw new JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone(jwks);
      }
      async getKey(protectedHeader, token) {
        const { alg, kid } = { ...protectedHeader, ...token == null ? void 0 : token.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk2) => {
          let candidate = kty === jwk2.kty;
          if (candidate && typeof kid === "string") {
            candidate = kid === jwk2.kid;
          }
          if (candidate && typeof jwk2.alg === "string") {
            candidate = alg === jwk2.alg;
          }
          if (candidate && typeof jwk2.use === "string") {
            candidate = jwk2.use === "sig";
          }
          if (candidate && Array.isArray(jwk2.key_ops)) {
            candidate = jwk2.key_ops.includes("verify");
          }
          if (candidate && alg === "EdDSA") {
            candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
          }
          if (candidate) {
            switch (alg) {
              case "ES256":
                candidate = jwk2.crv === "P-256";
                break;
              case "ES256K":
                candidate = jwk2.crv === "secp256k1";
                break;
              case "ES384":
                candidate = jwk2.crv === "P-384";
                break;
              case "ES512":
                candidate = jwk2.crv === "P-521";
                break;
            }
          }
          return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) {
          throw new JWKSNoMatchingKey();
        }
        if (length !== 1) {
          const error = new JWKSMultipleMatchingKeys();
          const { _cached } = this;
          error[Symbol.asyncIterator] = async function* () {
            for (const jwk2 of candidates) {
              try {
                yield await importWithAlgCache(_cached, jwk2, alg);
              } catch {
              }
            }
          };
          throw error;
        }
        return importWithAlgCache(this._cached, jwk, alg);
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/fetch_jwks.js
var fetchJwks, fetch_jwks_default;
var init_fetch_jwks = __esm({
  "node_modules/jose/dist/browser/runtime/fetch_jwks.js"() {
    init_errors();
    fetchJwks = async (url, timeout, options) => {
      let controller;
      let id;
      let timedOut = false;
      if (typeof AbortController === "function") {
        controller = new AbortController();
        id = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, timeout);
      }
      const response = await fetch(url.href, {
        signal: controller ? controller.signal : void 0,
        redirect: "manual",
        headers: options.headers
      }).catch((err) => {
        if (timedOut)
          throw new JWKSTimeout();
        throw err;
      });
      if (id !== void 0)
        clearTimeout(id);
      if (response.status !== 200) {
        throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
      }
      try {
        return await response.json();
      } catch {
        throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
      }
    };
    fetch_jwks_default = fetchJwks;
  }
});

// node_modules/jose/dist/browser/jwks/remote.js
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
function createRemoteJWKSet(url, options) {
  const set = new RemoteJWKSet(url, options);
  return async (protectedHeader, token) => set.getKey(protectedHeader, token);
}
var USER_AGENT, _a, _b, RemoteJWKSet;
var init_remote = __esm({
  "node_modules/jose/dist/browser/jwks/remote.js"() {
    init_fetch_jwks();
    init_errors();
    init_local();
    if (typeof navigator === "undefined" || !((_b = (_a = navigator.userAgent) == null ? void 0 : _a.startsWith) == null ? void 0 : _b.call(_a, "Mozilla/5.0 "))) {
      const NAME = "jose";
      const VERSION = "v5.2.2";
      USER_AGENT = `${NAME}/${VERSION}`;
    }
    RemoteJWKSet = class extends LocalJWKSet {
      constructor(url, options) {
        super({ keys: [] });
        this._jwks = void 0;
        if (!(url instanceof URL)) {
          throw new TypeError("url must be an instance of URL");
        }
        this._url = new URL(url.href);
        this._options = { agent: options == null ? void 0 : options.agent, headers: options == null ? void 0 : options.headers };
        this._timeoutDuration = typeof (options == null ? void 0 : options.timeoutDuration) === "number" ? options == null ? void 0 : options.timeoutDuration : 5e3;
        this._cooldownDuration = typeof (options == null ? void 0 : options.cooldownDuration) === "number" ? options == null ? void 0 : options.cooldownDuration : 3e4;
        this._cacheMaxAge = typeof (options == null ? void 0 : options.cacheMaxAge) === "number" ? options == null ? void 0 : options.cacheMaxAge : 6e5;
      }
      coolingDown() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
      }
      fresh() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
      }
      async getKey(protectedHeader, token) {
        if (!this._jwks || !this.fresh()) {
          await this.reload();
        }
        try {
          return await super.getKey(protectedHeader, token);
        } catch (err) {
          if (err instanceof JWKSNoMatchingKey) {
            if (this.coolingDown() === false) {
              await this.reload();
              return super.getKey(protectedHeader, token);
            }
          }
          throw err;
        }
      }
      async reload() {
        if (this._pendingFetch && isCloudflareWorkers()) {
          this._pendingFetch = void 0;
        }
        const headers = new Headers(this._options.headers);
        if (USER_AGENT && !headers.has("User-Agent")) {
          headers.set("User-Agent", USER_AGENT);
          this._options.headers = Object.fromEntries(headers.entries());
        }
        this._pendingFetch || (this._pendingFetch = fetch_jwks_default(this._url, this._timeoutDuration, this._options).then((json) => {
          if (!isJWKSLike(json)) {
            throw new JWKSInvalid("JSON Web Key Set malformed");
          }
          this._jwks = { keys: json.keys };
          this._jwksTimestamp = Date.now();
          this._pendingFetch = void 0;
        }).catch((err) => {
          this._pendingFetch = void 0;
          throw err;
        }));
        await this._pendingFetch;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/unsecured.js
var UnsecuredJWT;
var init_unsecured = __esm({
  "node_modules/jose/dist/browser/jwt/unsecured.js"() {
    init_base64url();
    init_buffer_utils();
    init_errors();
    init_jwt_claims_set();
    init_produce();
    UnsecuredJWT = class extends ProduceJWT {
      encode() {
        const header = encode(JSON.stringify({ alg: "none" }));
        const payload = encode(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
      }
      static decode(jwt, options) {
        if (typeof jwt !== "string") {
          throw new JWTInvalid("Unsecured JWT must be a string");
        }
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split(".");
        if (length !== 3 || signature !== "") {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        let header;
        try {
          header = JSON.parse(decoder.decode(decode(encodedHeader)));
          if (header.alg !== "none")
            throw new Error();
        } catch {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        const payload = jwt_claims_set_default(header, decode(encodedPayload), options);
        return { payload, header };
      }
    };
  }
});

// node_modules/jose/dist/browser/util/base64url.js
var base64url_exports2 = {};
__export(base64url_exports2, {
  decode: () => decode2,
  encode: () => encode2
});
var encode2, decode2;
var init_base64url2 = __esm({
  "node_modules/jose/dist/browser/util/base64url.js"() {
    init_base64url();
    encode2 = encode;
    decode2 = decode;
  }
});

// node_modules/jose/dist/browser/util/decode_protected_header.js
function decodeProtectedHeader(token) {
  let protectedB64u;
  if (typeof token === "string") {
    const parts = token.split(".");
    if (parts.length === 3 || parts.length === 5) {
      ;
      [protectedB64u] = parts;
    }
  } else if (typeof token === "object" && token) {
    if ("protected" in token) {
      protectedB64u = token.protected;
    } else {
      throw new TypeError("Token does not contain a Protected Header");
    }
  }
  try {
    if (typeof protectedB64u !== "string" || !protectedB64u) {
      throw new Error();
    }
    const result = JSON.parse(decoder.decode(decode2(protectedB64u)));
    if (!isObject(result)) {
      throw new Error();
    }
    return result;
  } catch {
    throw new TypeError("Invalid Token or Protected Header formatting");
  }
}
var init_decode_protected_header = __esm({
  "node_modules/jose/dist/browser/util/decode_protected_header.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/util/decode_jwt.js
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode2(payload);
  } catch {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}
var init_decode_jwt = __esm({
  "node_modules/jose/dist/browser/util/decode_jwt.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/generate.js
async function generateSecret(alg, options) {
  let length;
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      length = parseInt(alg.slice(-3), 10);
      algorithm = { name: "HMAC", hash: `SHA-${length}`, length };
      keyUsages = ["sign", "verify"];
      break;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      length = parseInt(alg.slice(-3), 10);
      return random_default(new Uint8Array(length >> 3));
    case "A128KW":
    case "A192KW":
    case "A256KW":
      length = parseInt(alg.slice(1, 4), 10);
      algorithm = { name: "AES-KW", length };
      keyUsages = ["wrapKey", "unwrapKey"];
      break;
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW":
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      length = parseInt(alg.slice(1, 4), 10);
      algorithm = { name: "AES-GCM", length };
      keyUsages = ["encrypt", "decrypt"];
      break;
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, (options == null ? void 0 : options.extractable) ?? false, keyUsages);
}
function getModulusLengthOption(options) {
  const modulusLength = (options == null ? void 0 : options.modulusLength) ?? 2048;
  if (typeof modulusLength !== "number" || modulusLength < 2048) {
    throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
  }
  return modulusLength;
}
async function generateKeyPair(alg, options) {
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "PS256":
    case "PS384":
    case "PS512":
      algorithm = {
        name: "RSA-PSS",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      algorithm = {
        name: "RSASSA-PKCS1-v1_5",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      algorithm = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["decrypt", "unwrapKey", "encrypt", "wrapKey"];
      break;
    case "ES256":
      algorithm = { name: "ECDSA", namedCurve: "P-256" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES384":
      algorithm = { name: "ECDSA", namedCurve: "P-384" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES512":
      algorithm = { name: "ECDSA", namedCurve: "P-521" };
      keyUsages = ["sign", "verify"];
      break;
    case "EdDSA": {
      keyUsages = ["sign", "verify"];
      const crv = (options == null ? void 0 : options.crv) ?? "Ed25519";
      switch (crv) {
        case "Ed25519":
        case "Ed448":
          algorithm = { name: crv };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided");
      }
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      keyUsages = ["deriveKey", "deriveBits"];
      const crv = (options == null ? void 0 : options.crv) ?? "P-256";
      switch (crv) {
        case "P-256":
        case "P-384":
        case "P-521": {
          algorithm = { name: "ECDH", namedCurve: crv };
          break;
        }
        case "X25519":
        case "X448":
          algorithm = { name: crv };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, (options == null ? void 0 : options.extractable) ?? false, keyUsages);
}
var init_generate = __esm({
  "node_modules/jose/dist/browser/runtime/generate.js"() {
    init_webcrypto();
    init_errors();
    init_random();
  }
});

// node_modules/jose/dist/browser/key/generate_key_pair.js
async function generateKeyPair2(alg, options) {
  return generateKeyPair(alg, options);
}
var init_generate_key_pair = __esm({
  "node_modules/jose/dist/browser/key/generate_key_pair.js"() {
    init_generate();
  }
});

// node_modules/jose/dist/browser/key/generate_secret.js
async function generateSecret2(alg, options) {
  return generateSecret(alg, options);
}
var init_generate_secret = __esm({
  "node_modules/jose/dist/browser/key/generate_secret.js"() {
    init_generate();
  }
});

// node_modules/jose/dist/browser/runtime/runtime.js
var runtime_default;
var init_runtime = __esm({
  "node_modules/jose/dist/browser/runtime/runtime.js"() {
    runtime_default = "WebCryptoAPI";
  }
});

// node_modules/jose/dist/browser/util/runtime.js
var runtime_default2;
var init_runtime2 = __esm({
  "node_modules/jose/dist/browser/util/runtime.js"() {
    init_runtime();
    runtime_default2 = runtime_default;
  }
});

// node_modules/jose/dist/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  CompactEncrypt: () => CompactEncrypt,
  CompactSign: () => CompactSign,
  EmbeddedJWK: () => EmbeddedJWK,
  EncryptJWT: () => EncryptJWT,
  FlattenedEncrypt: () => FlattenedEncrypt,
  FlattenedSign: () => FlattenedSign,
  GeneralEncrypt: () => GeneralEncrypt,
  GeneralSign: () => GeneralSign,
  SignJWT: () => SignJWT,
  UnsecuredJWT: () => UnsecuredJWT,
  base64url: () => base64url_exports2,
  calculateJwkThumbprint: () => calculateJwkThumbprint,
  calculateJwkThumbprintUri: () => calculateJwkThumbprintUri,
  compactDecrypt: () => compactDecrypt,
  compactVerify: () => compactVerify,
  createLocalJWKSet: () => createLocalJWKSet,
  createRemoteJWKSet: () => createRemoteJWKSet,
  cryptoRuntime: () => runtime_default2,
  decodeJwt: () => decodeJwt,
  decodeProtectedHeader: () => decodeProtectedHeader,
  errors: () => errors_exports,
  exportJWK: () => exportJWK,
  exportPKCS8: () => exportPKCS8,
  exportSPKI: () => exportSPKI,
  flattenedDecrypt: () => flattenedDecrypt,
  flattenedVerify: () => flattenedVerify,
  generalDecrypt: () => generalDecrypt,
  generalVerify: () => generalVerify,
  generateKeyPair: () => generateKeyPair2,
  generateSecret: () => generateSecret2,
  importJWK: () => importJWK,
  importPKCS8: () => importPKCS8,
  importSPKI: () => importSPKI,
  importX509: () => importX509,
  jwtDecrypt: () => jwtDecrypt,
  jwtVerify: () => jwtVerify
});
var init_browser = __esm({
  "node_modules/jose/dist/browser/index.js"() {
    init_decrypt3();
    init_decrypt2();
    init_decrypt4();
    init_encrypt3();
    init_verify3();
    init_verify2();
    init_verify4();
    init_verify5();
    init_decrypt5();
    init_encrypt4();
    init_encrypt2();
    init_sign3();
    init_sign2();
    init_sign4();
    init_sign5();
    init_encrypt5();
    init_thumbprint();
    init_embedded();
    init_local();
    init_remote();
    init_unsecured();
    init_export();
    init_import();
    init_decode_protected_header();
    init_decode_jwt();
    init_errors();
    init_generate_key_pair();
    init_generate_secret();
    init_base64url2();
    init_runtime2();
  }
});

// node_modules/@shopify/shopify-api/lib/utils/get-hmac-key.js
var require_get_hmac_key = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/get-hmac-key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHMACKey = void 0;
    function getHMACKey(key) {
      const arrayBuffer = new Uint8Array(key.length);
      for (let i = 0, keyLen = key.length; i < keyLen; i++) {
        arrayBuffer[i] = key.charCodeAt(i);
      }
      return arrayBuffer;
    }
    exports.getHMACKey = getHMACKey;
  }
});

// node_modules/@shopify/shopify-api/lib/session/decode-session-token.js
var require_decode_session_token = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/decode-session-token.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeSessionToken = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var jose = tslib_1.__importStar((init_browser(), __toCommonJS(browser_exports)));
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var get_hmac_key_1 = require_get_hmac_key();
    var JWT_PERMITTED_CLOCK_TOLERANCE = 10;
    function decodeSessionToken(config) {
      return (token, { checkAudience = true } = {}) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let payload;
        try {
          payload = (yield jose.jwtVerify(token, (0, get_hmac_key_1.getHMACKey)(config.apiSecretKey), {
            algorithms: ["HS256"],
            clockTolerance: JWT_PERMITTED_CLOCK_TOLERANCE
          })).payload;
        } catch (error) {
          throw new ShopifyErrors.InvalidJwtError(`Failed to parse session token '${token}': ${error.message}`);
        }
        if (checkAudience && payload.aud !== config.apiKey) {
          throw new ShopifyErrors.InvalidJwtError("Session token had invalid API key");
        }
        return payload;
      });
    }
    exports.decodeSessionToken = decodeSessionToken;
  }
});

// node_modules/@shopify/shopify-api/lib/session/session-utils.js
var require_session_utils = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/session-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.customAppSession = exports.getCurrentSessionId = exports.getOfflineId = exports.getJwtSessionId = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var types_1 = require_types4();
    var http_1 = require_http();
    var shop_validator_1 = require_shop_validator();
    var logger_1 = require_logger();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var decode_session_token_1 = require_decode_session_token();
    var session_1 = require_session();
    function getJwtSessionId(config) {
      return (shop, userId) => {
        return `${(0, shop_validator_1.sanitizeShop)(config)(shop, true)}_${userId}`;
      };
    }
    exports.getJwtSessionId = getJwtSessionId;
    function getOfflineId(config) {
      return (shop) => {
        return `offline_${(0, shop_validator_1.sanitizeShop)(config)(shop, true)}`;
      };
    }
    exports.getOfflineId = getOfflineId;
    function getCurrentSessionId(config) {
      return function getCurrentSessionId2(_a2) {
        var { isOnline } = _a2, adapterArgs = tslib_1.__rest(_a2, ["isOnline"]);
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const request = yield (0, http_1.abstractConvertRequest)(adapterArgs);
          const log = (0, logger_1.logger)(config);
          if (config.isEmbeddedApp) {
            log.debug("App is embedded, looking for session id in JWT payload", {
              isOnline
            });
            const authHeader = request.headers.Authorization;
            if (authHeader) {
              const matches = (typeof authHeader === "string" ? authHeader : authHeader[0]).match(/^Bearer (.+)$/);
              if (!matches) {
                log.error("Missing Bearer token in authorization header", { isOnline });
                throw new ShopifyErrors.MissingJwtTokenError("Missing Bearer token in authorization header");
              }
              const jwtPayload = yield (0, decode_session_token_1.decodeSessionToken)(config)(matches[1]);
              const shop = jwtPayload.dest.replace(/^https:\/\//, "");
              log.debug("Found valid JWT payload", { shop, isOnline });
              if (isOnline) {
                return getJwtSessionId(config)(shop, jwtPayload.sub);
              } else {
                return getOfflineId(config)(shop);
              }
            } else {
              log.error("Missing Authorization header, was the request made with authenticatedFetch?", { isOnline });
            }
          } else {
            log.debug("App is not embedded, looking for session id in cookies", {
              isOnline
            });
            const cookies = new http_1.Cookies(request, {}, {
              keys: [config.apiSecretKey]
            });
            return cookies.getAndVerify(types_1.SESSION_COOKIE_NAME);
          }
          return void 0;
        });
      };
    }
    exports.getCurrentSessionId = getCurrentSessionId;
    function customAppSession(config) {
      return (shop) => {
        return new session_1.Session({
          id: "",
          shop: `${(0, shop_validator_1.sanitizeShop)(config)(shop, true)}`,
          state: "",
          isOnline: false
        });
      };
    }
    exports.customAppSession = customAppSession;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/create-session.js
var require_create_session = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/create-session.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSession = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var uuid_1 = require_commonjs_browser();
    var session_1 = require_session();
    var logger_1 = require_logger();
    var session_utils_1 = require_session_utils();
    function createSession({ config, accessTokenResponse, shop, state }) {
      const associatedUser = accessTokenResponse.associated_user;
      const isOnline = Boolean(associatedUser);
      (0, logger_1.logger)(config).info("Creating new session", { shop, isOnline });
      if (isOnline) {
        let sessionId;
        const responseBody = accessTokenResponse;
        const { access_token, scope } = responseBody, rest = tslib_1.__rest(responseBody, ["access_token", "scope"]);
        const sessionExpiration = new Date(Date.now() + responseBody.expires_in * 1e3);
        if (config.isEmbeddedApp) {
          sessionId = (0, session_utils_1.getJwtSessionId)(config)(shop, `${rest.associated_user.id}`);
        } else {
          sessionId = (0, uuid_1.v4)();
        }
        return new session_1.Session({
          id: sessionId,
          shop,
          state,
          isOnline,
          accessToken: access_token,
          scope,
          expires: sessionExpiration,
          onlineAccessInfo: rest
        });
      } else {
        return new session_1.Session({
          id: (0, session_utils_1.getOfflineId)(config)(shop),
          shop,
          state,
          isOnline,
          accessToken: accessTokenResponse.access_token,
          scope: accessTokenResponse.scope
        });
      }
    }
    exports.createSession = createSession;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/oauth.js
var require_oauth = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/oauth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callback = exports.begin = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var isbot_1 = require_isbot();
    var common_1 = require_common();
    var processed_query_1 = tslib_1.__importDefault(require_processed_query());
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var hmac_validator_1 = require_hmac_validator();
    var shop_validator_1 = require_shop_validator();
    var http_1 = require_http();
    var logger_1 = require_logger();
    var types_1 = require_types3();
    var types_2 = require_types4();
    var nonce_1 = require_nonce();
    var safe_compare_1 = require_safe_compare();
    var create_session_1 = require_create_session();
    var logForBot = ({ request, log, func }) => {
      log.debug(`Possible bot request to auth ${func}: `, {
        userAgent: request.headers["User-Agent"]
      });
    };
    function begin(config) {
      return (_a2) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        var { shop, callbackPath, isOnline } = _a2, adapterArgs = tslib_1.__rest(_a2, ["shop", "callbackPath", "isOnline"]);
        throwIfCustomStoreApp(config.isCustomStoreApp, "Cannot perform OAuth for private apps");
        const log = (0, logger_1.logger)(config);
        log.info("Beginning OAuth", { shop, isOnline, callbackPath });
        const request = yield (0, http_1.abstractConvertRequest)(adapterArgs);
        const response = yield (0, http_1.abstractConvertIncomingResponse)(adapterArgs);
        let userAgent = request.headers["User-Agent"];
        if (Array.isArray(userAgent)) {
          userAgent = userAgent[0];
        }
        if ((0, isbot_1.isbot)(userAgent)) {
          logForBot({ request, log, func: "begin" });
          response.statusCode = 410;
          return (0, http_1.abstractConvertResponse)(response, adapterArgs);
        }
        const cookies = new http_1.Cookies(request, response, {
          keys: [config.apiSecretKey],
          secure: true
        });
        const state = (0, nonce_1.nonce)();
        yield cookies.setAndSign(types_2.STATE_COOKIE_NAME, state, {
          expires: new Date(Date.now() + 6e4),
          sameSite: "lax",
          secure: true,
          path: callbackPath
        });
        const query = {
          client_id: config.apiKey,
          scope: config.scopes.toString(),
          redirect_uri: `${config.hostScheme}://${config.hostName}${callbackPath}`,
          state,
          "grant_options[]": isOnline ? "per-user" : ""
        };
        const processedQuery = new processed_query_1.default();
        processedQuery.putAll(query);
        const cleanShop = (0, shop_validator_1.sanitizeShop)(config)(shop, true);
        const redirectUrl = `https://${cleanShop}/admin/oauth/authorize${processedQuery.stringify()}`;
        response.statusCode = 302;
        response.statusText = "Found";
        response.headers = Object.assign(Object.assign(Object.assign({}, response.headers), cookies.response.headers), { Location: redirectUrl });
        log.debug(`OAuth started, redirecting to ${redirectUrl}`, { shop, isOnline });
        return (0, http_1.abstractConvertResponse)(response, adapterArgs);
      });
    }
    exports.begin = begin;
    function callback(config) {
      return function callback2(_a2) {
        var adapterArgs = tslib_1.__rest(_a2, []);
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          throwIfCustomStoreApp(config.isCustomStoreApp, "Cannot perform OAuth for private apps");
          const log = (0, logger_1.logger)(config);
          const request = yield (0, http_1.abstractConvertRequest)(adapterArgs);
          const query = new URL(request.url, `${config.hostScheme}://${config.hostName}`).searchParams;
          const shop = query.get("shop");
          const response = {};
          let userAgent = request.headers["User-Agent"];
          if (Array.isArray(userAgent)) {
            userAgent = userAgent[0];
          }
          if ((0, isbot_1.isbot)(userAgent)) {
            logForBot({ request, log, func: "callback" });
            throw new ShopifyErrors.BotActivityDetected("Invalid OAuth callback initiated by bot");
          }
          log.info("Completing OAuth", { shop });
          const cookies = new http_1.Cookies(request, response, {
            keys: [config.apiSecretKey],
            secure: true
          });
          const stateFromCookie = yield cookies.getAndVerify(types_2.STATE_COOKIE_NAME);
          cookies.deleteCookie(types_2.STATE_COOKIE_NAME);
          if (!stateFromCookie) {
            log.error("Could not find OAuth cookie", { shop });
            throw new ShopifyErrors.CookieNotFound(`Cannot complete OAuth process. Could not find an OAuth cookie for shop url: ${shop}`);
          }
          const authQuery = Object.fromEntries(query.entries());
          if (!(yield validQuery({ config, query: authQuery, stateFromCookie }))) {
            log.error("Invalid OAuth callback", { shop, stateFromCookie });
            throw new ShopifyErrors.InvalidOAuthError("Invalid OAuth callback.");
          }
          log.debug("OAuth request is valid, requesting access token", { shop });
          const body = {
            client_id: config.apiKey,
            client_secret: config.apiSecretKey,
            code: query.get("code")
          };
          const cleanShop = (0, shop_validator_1.sanitizeShop)(config)(query.get("shop"), true);
          const postResponse = yield (0, http_1.abstractFetch)(`https://${cleanShop}/admin/oauth/access_token`, {
            method: "POST",
            body: JSON.stringify(body),
            headers: {
              "Content-Type": types_1.DataType.JSON,
              Accept: types_1.DataType.JSON
            }
          });
          if (!postResponse.ok) {
            (0, common_1.throwFailedRequest)(yield postResponse.json(), postResponse, false);
          }
          const session = (0, create_session_1.createSession)({
            accessTokenResponse: yield postResponse.json(),
            shop: cleanShop,
            state: stateFromCookie,
            config
          });
          if (!config.isEmbeddedApp) {
            yield cookies.setAndSign(types_2.SESSION_COOKIE_NAME, session.id, {
              expires: session.expires,
              sameSite: "lax",
              secure: true,
              path: "/"
            });
          }
          return {
            headers: yield (0, http_1.abstractConvertHeaders)(cookies.response.headers, adapterArgs),
            session
          };
        });
      };
    }
    exports.callback = callback;
    function validQuery({ config, query, stateFromCookie }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return (yield (0, hmac_validator_1.validateHmac)(config)(query)) && (0, safe_compare_1.safeCompare)(query.state, stateFromCookie);
      });
    }
    function throwIfCustomStoreApp(isCustomStoreApp, message2) {
      if (isCustomStoreApp) {
        throw new ShopifyErrors.PrivateAppError(message2);
      }
    }
  }
});

// node_modules/@shopify/shopify-api/lib/auth/get-embedded-app-url.js
var require_get_embedded_app_url = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/get-embedded-app-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildEmbeddedAppUrl = exports.getEmbeddedAppUrl = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var http_1 = require_http();
    var shop_validator_1 = require_shop_validator();
    var decode_host_1 = require_decode_host();
    function getEmbeddedAppUrl(config) {
      return (_a2) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        var adapterArgs = tslib_1.__rest(_a2, []);
        const request = yield (0, http_1.abstractConvertRequest)(adapterArgs);
        if (!request) {
          throw new ShopifyErrors.MissingRequiredArgument("getEmbeddedAppUrl requires a request object argument");
        }
        if (!request.url) {
          throw new ShopifyErrors.InvalidRequestError("Request does not contain a URL");
        }
        const url = new URL(request.url, `https://${request.headers.host}`);
        const host = url.searchParams.get("host");
        if (typeof host !== "string") {
          throw new ShopifyErrors.InvalidRequestError("Request does not contain a host query parameter");
        }
        return buildEmbeddedAppUrl(config)(host);
      });
    }
    exports.getEmbeddedAppUrl = getEmbeddedAppUrl;
    function buildEmbeddedAppUrl(config) {
      return (host) => {
        (0, shop_validator_1.sanitizeHost)()(host, true);
        const decodedHost = (0, decode_host_1.decodeHost)(host);
        return `https://${decodedHost}/apps/${config.apiKey}`;
      };
    }
    exports.buildEmbeddedAppUrl = buildEmbeddedAppUrl;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/oauth/token-exchange.js
var require_token_exchange = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/oauth/token-exchange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenExchange = exports.RequestedTokenType = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var common_1 = require_common();
    var decode_session_token_1 = require_decode_session_token();
    var shop_validator_1 = require_shop_validator();
    var runtime_1 = require_runtime();
    var types_1 = require_types3();
    var create_session_1 = require_create_session();
    var RequestedTokenType;
    (function(RequestedTokenType2) {
      RequestedTokenType2["OnlineAccessToken"] = "urn:shopify:params:oauth:token-type:online-access-token";
      RequestedTokenType2["OfflineAccessToken"] = "urn:shopify:params:oauth:token-type:offline-access-token";
    })(RequestedTokenType || (exports.RequestedTokenType = RequestedTokenType = {}));
    var TokenExchangeGrantType = "urn:ietf:params:oauth:grant-type:token-exchange";
    var IdTokenType = "urn:ietf:params:oauth:token-type:id_token";
    function tokenExchange(config) {
      return ({ shop, sessionToken, requestedTokenType }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield (0, decode_session_token_1.decodeSessionToken)(config)(sessionToken);
        const body = {
          client_id: config.apiKey,
          client_secret: config.apiSecretKey,
          grant_type: TokenExchangeGrantType,
          subject_token: sessionToken,
          subject_token_type: IdTokenType,
          requested_token_type: requestedTokenType
        };
        const cleanShop = (0, shop_validator_1.sanitizeShop)(config)(shop, true);
        const postResponse = yield (0, runtime_1.abstractFetch)(`https://${cleanShop}/admin/oauth/access_token`, {
          method: "POST",
          body: JSON.stringify(body),
          headers: {
            "Content-Type": types_1.DataType.JSON,
            Accept: types_1.DataType.JSON
          }
        });
        if (!postResponse.ok) {
          (0, common_1.throwFailedRequest)(yield postResponse.json(), postResponse, false);
        }
        return {
          session: (0, create_session_1.createSession)({
            accessTokenResponse: yield postResponse.json(),
            shop: cleanShop,
            // We need to keep this as an empty string as our template DB schemas have this required
            state: "",
            config
          })
        };
      });
    }
    exports.tokenExchange = tokenExchange;
  }
});

// node_modules/@shopify/shopify-api/lib/auth/index.js
var require_auth = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyAuth = void 0;
    var oauth_1 = require_oauth();
    var nonce_1 = require_nonce();
    var safe_compare_1 = require_safe_compare();
    var get_embedded_app_url_1 = require_get_embedded_app_url();
    var token_exchange_1 = require_token_exchange();
    function shopifyAuth(config) {
      const shopify = {
        begin: (0, oauth_1.begin)(config),
        callback: (0, oauth_1.callback)(config),
        nonce: nonce_1.nonce,
        safeCompare: safe_compare_1.safeCompare,
        getEmbeddedAppUrl: (0, get_embedded_app_url_1.getEmbeddedAppUrl)(config),
        buildEmbeddedAppUrl: (0, get_embedded_app_url_1.buildEmbeddedAppUrl)(config),
        tokenExchange: (0, token_exchange_1.tokenExchange)(config)
      };
      return shopify;
    }
    exports.shopifyAuth = shopifyAuth;
  }
});

// node_modules/@shopify/shopify-api/lib/session/index.js
var require_session2 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifySession = void 0;
    var decode_session_token_1 = require_decode_session_token();
    var session_utils_1 = require_session_utils();
    function shopifySession(config) {
      return {
        customAppSession: (0, session_utils_1.customAppSession)(config),
        getCurrentId: (0, session_utils_1.getCurrentSessionId)(config),
        getOfflineId: (0, session_utils_1.getOfflineId)(config),
        getJwtSessionId: (0, session_utils_1.getJwtSessionId)(config),
        decodeSessionToken: (0, decode_session_token_1.decodeSessionToken)(config)
      };
    }
    exports.shopifySession = shopifySession;
  }
});

// node_modules/@shopify/shopify-api/lib/utils/version-compatible.js
var require_version_compatible = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/version-compatible.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.versionPriorTo = exports.versionCompatible = void 0;
    var types_1 = require_types2();
    function versionCompatible(config) {
      return (referenceVersion, currentVersion = config.apiVersion) => {
        if (currentVersion === types_1.ApiVersion.Unstable) {
          return true;
        }
        const numericVersion = (version) => parseInt(version.replace("-", ""), 10);
        const current = numericVersion(currentVersion);
        const reference = numericVersion(referenceVersion);
        return current >= reference;
      };
    }
    exports.versionCompatible = versionCompatible;
    function versionPriorTo(config) {
      return (referenceVersion, currentVersion = config.apiVersion) => {
        return !versionCompatible(config)(referenceVersion, currentVersion);
      };
    }
    exports.versionPriorTo = versionPriorTo;
  }
});

// node_modules/@shopify/shopify-api/lib/utils/index.js
var require_utils = __commonJS({
  "node_modules/@shopify/shopify-api/lib/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyUtils = void 0;
    var shop_validator_1 = require_shop_validator();
    var hmac_validator_1 = require_hmac_validator();
    var version_compatible_1 = require_version_compatible();
    var shop_admin_url_helper_1 = require_shop_admin_url_helper();
    function shopifyUtils(config) {
      return {
        sanitizeShop: (0, shop_validator_1.sanitizeShop)(config),
        sanitizeHost: (0, shop_validator_1.sanitizeHost)(),
        validateHmac: (0, hmac_validator_1.validateHmac)(config),
        versionCompatible: (0, version_compatible_1.versionCompatible)(config),
        versionPriorTo: (0, version_compatible_1.versionPriorTo)(config),
        shopAdminUrlToLegacyUrl: shop_admin_url_helper_1.shopAdminUrlToLegacyUrl,
        legacyUrlToShopAdminUrl: shop_admin_url_helper_1.legacyUrlToShopAdminUrl
      };
    }
    exports.shopifyUtils = shopifyUtils;
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/types.js
var require_types5 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebhookValidationErrorReason = exports.WebhookOperation = exports.DeliveryMethod = void 0;
    var DeliveryMethod;
    (function(DeliveryMethod2) {
      DeliveryMethod2["Http"] = "http";
      DeliveryMethod2["EventBridge"] = "eventbridge";
      DeliveryMethod2["PubSub"] = "pubsub";
    })(DeliveryMethod || (exports.DeliveryMethod = DeliveryMethod = {}));
    var WebhookOperation;
    (function(WebhookOperation2) {
      WebhookOperation2["Create"] = "create";
      WebhookOperation2["Update"] = "update";
      WebhookOperation2["Delete"] = "delete";
    })(WebhookOperation || (exports.WebhookOperation = WebhookOperation = {}));
    var WebhookValidationErrorReason;
    (function(WebhookValidationErrorReason2) {
      WebhookValidationErrorReason2["MissingHeaders"] = "missing_headers";
      WebhookValidationErrorReason2["MissingBody"] = "missing_body";
      WebhookValidationErrorReason2["InvalidHmac"] = "invalid_hmac";
    })(WebhookValidationErrorReason || (exports.WebhookValidationErrorReason = WebhookValidationErrorReason = {}));
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/registry.js
var require_registry = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addHostToCallbackUrl = exports.handlerIdentifier = exports.getHandlers = exports.getTopicsAdded = exports.addHandlers = exports.topicForStorage = exports.registry = void 0;
    var error_1 = require_error();
    var logger_1 = require_logger();
    var types_1 = require_types5();
    function registry() {
      return {};
    }
    exports.registry = registry;
    function topicForStorage(topic) {
      return topic.toUpperCase().replace(/\/|\./g, "_");
    }
    exports.topicForStorage = topicForStorage;
    function addHandlers(config, webhookRegistry) {
      return function addHandlers2(handlersToAdd) {
        for (const [topic, handlers] of Object.entries(handlersToAdd)) {
          const topicKey = topicForStorage(topic);
          if (Array.isArray(handlers)) {
            for (const handler of handlers) {
              mergeOrAddHandler(config, webhookRegistry, topicKey, handler);
            }
          } else {
            mergeOrAddHandler(config, webhookRegistry, topicKey, handlers);
          }
        }
      };
    }
    exports.addHandlers = addHandlers;
    function getTopicsAdded(webhookRegistry) {
      return function getTopicsAdded2() {
        return Object.keys(webhookRegistry);
      };
    }
    exports.getTopicsAdded = getTopicsAdded;
    function getHandlers(webhookRegistry) {
      return function getHandlers2(topic) {
        return webhookRegistry[topicForStorage(topic)] || [];
      };
    }
    exports.getHandlers = getHandlers;
    function handlerIdentifier(config, handler) {
      const prefix = handler.deliveryMethod;
      switch (handler.deliveryMethod) {
        case types_1.DeliveryMethod.Http:
          return `${prefix}_${addHostToCallbackUrl(config, handler.callbackUrl)}`;
        case types_1.DeliveryMethod.EventBridge:
          return `${prefix}_${handler.arn}`;
        case types_1.DeliveryMethod.PubSub:
          return `${prefix}_${handler.pubSubProject}:${handler.pubSubTopic}`;
        default:
          throw new error_1.InvalidDeliveryMethodError(`Unrecognized delivery method '${handler.deliveryMethod}'`);
      }
    }
    exports.handlerIdentifier = handlerIdentifier;
    function addHostToCallbackUrl(config, callbackUrl) {
      if (callbackUrl.startsWith("/")) {
        return `${config.hostScheme}://${config.hostName}${callbackUrl}`;
      } else {
        return callbackUrl;
      }
    }
    exports.addHostToCallbackUrl = addHostToCallbackUrl;
    function mergeOrAddHandler(config, webhookRegistry, topic, handler) {
      var _a2, _b2;
      const log = (0, logger_1.logger)(config);
      (_a2 = handler.includeFields) === null || _a2 === void 0 ? void 0 : _a2.sort();
      (_b2 = handler.metafieldNamespaces) === null || _b2 === void 0 ? void 0 : _b2.sort();
      if (!(topic in webhookRegistry)) {
        webhookRegistry[topic] = [handler];
        return;
      }
      const identifier = handlerIdentifier(config, handler);
      for (const index in webhookRegistry[topic]) {
        if (!Object.prototype.hasOwnProperty.call(webhookRegistry[topic], index)) {
          continue;
        }
        const existingHandler = webhookRegistry[topic][index];
        const existingIdentifier = handlerIdentifier(config, existingHandler);
        if (identifier !== existingIdentifier) {
          continue;
        }
        if (handler.deliveryMethod === types_1.DeliveryMethod.Http) {
          log.info(`Detected multiple handlers for '${topic}', webhooks.process will call them sequentially`);
          break;
        } else {
          throw new error_1.InvalidDeliveryMethodError(`Can only add multiple handlers when deliveryMethod is Http. Invalid handler: ${JSON.stringify(handler)}`);
        }
      }
      webhookRegistry[topic].push(handler);
    }
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/query-template.js
var require_query_template = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/query-template.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.queryTemplate = void 0;
    function queryTemplate(template, params) {
      let query = template;
      Object.entries(params).forEach(([key, value]) => {
        query = query.replace(`{{${key}}}`, value);
      });
      return query;
    }
    exports.queryTemplate = queryTemplate;
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/register.js
var require_register = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/register.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TEMPLATE_MUTATION = exports.TEMPLATE_GET_HANDLERS = exports.register = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var admin_1 = require_admin();
    var error_1 = require_error();
    var logger_1 = require_logger();
    var types_1 = require_types2();
    var registry_1 = require_registry();
    var query_template_1 = require_query_template();
    var types_2 = require_types5();
    function register(config, webhookRegistry) {
      return function register2({ session }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const log = (0, logger_1.logger)(config);
          log.info("Registering webhooks", { shop: session.shop });
          const registerReturn = Object.keys(webhookRegistry).reduce((acc, topic) => {
            acc[topic] = [];
            return acc;
          }, {});
          const existingHandlers = yield getExistingHandlers(config, session);
          log.debug(`Existing topics: [${Object.keys(existingHandlers).join(", ")}]`, { shop: session.shop });
          for (const topic in webhookRegistry) {
            if (!Object.prototype.hasOwnProperty.call(webhookRegistry, topic)) {
              continue;
            }
            if (types_1.privacyTopics.includes(topic)) {
              continue;
            }
            registerReturn[topic] = yield registerTopic({
              config,
              session,
              topic,
              existingHandlers: existingHandlers[topic] || [],
              handlers: (0, registry_1.getHandlers)(webhookRegistry)(topic)
            });
            delete existingHandlers[topic];
          }
          for (const topic in existingHandlers) {
            if (!Object.prototype.hasOwnProperty.call(existingHandlers, topic)) {
              continue;
            }
            const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
            const client = new GraphqlClient({ session });
            registerReturn[topic] = yield runMutations({
              config,
              client,
              topic,
              handlers: existingHandlers[topic],
              operation: types_2.WebhookOperation.Delete
            });
          }
          return registerReturn;
        });
      };
    }
    exports.register = register;
    function getExistingHandlers(config, session) {
      var _a2, _b2, _c, _d, _e, _f;
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
        const client = new GraphqlClient({ session });
        const existingHandlers = {};
        let hasNextPage;
        let endCursor = null;
        do {
          const query = buildCheckQuery(endCursor);
          const response = yield client.request(query);
          (_b2 = (_a2 = response.data) === null || _a2 === void 0 ? void 0 : _a2.webhookSubscriptions) === null || _b2 === void 0 ? void 0 : _b2.edges.forEach((edge) => {
            const handler = buildHandlerFromNode(edge);
            if (!existingHandlers[edge.node.topic]) {
              existingHandlers[edge.node.topic] = [];
            }
            existingHandlers[edge.node.topic].push(handler);
          });
          endCursor = (_d = (_c = response.data) === null || _c === void 0 ? void 0 : _c.webhookSubscriptions) === null || _d === void 0 ? void 0 : _d.pageInfo.endCursor;
          hasNextPage = (_f = (_e = response.data) === null || _e === void 0 ? void 0 : _e.webhookSubscriptions) === null || _f === void 0 ? void 0 : _f.pageInfo.hasNextPage;
        } while (hasNextPage);
        return existingHandlers;
      });
    }
    function buildCheckQuery(endCursor) {
      return (0, query_template_1.queryTemplate)(exports.TEMPLATE_GET_HANDLERS, {
        END_CURSOR: JSON.stringify(endCursor)
      });
    }
    function buildHandlerFromNode(edge) {
      var _a2, _b2;
      const endpoint = edge.node.endpoint;
      let handler;
      switch (endpoint.__typename) {
        case "WebhookHttpEndpoint":
          handler = {
            deliveryMethod: types_2.DeliveryMethod.Http,
            callbackUrl: endpoint.callbackUrl,
            // This is a dummy for now because we don't really care about it
            callback: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            })
          };
          break;
        case "WebhookEventBridgeEndpoint":
          handler = {
            deliveryMethod: types_2.DeliveryMethod.EventBridge,
            arn: endpoint.arn
          };
          break;
        case "WebhookPubSubEndpoint":
          handler = {
            deliveryMethod: types_2.DeliveryMethod.PubSub,
            pubSubProject: endpoint.pubSubProject,
            pubSubTopic: endpoint.pubSubTopic
          };
          break;
      }
      handler.id = edge.node.id;
      handler.includeFields = edge.node.includeFields;
      handler.metafieldNamespaces = edge.node.metafieldNamespaces;
      (_a2 = handler.includeFields) === null || _a2 === void 0 ? void 0 : _a2.sort();
      (_b2 = handler.metafieldNamespaces) === null || _b2 === void 0 ? void 0 : _b2.sort();
      return handler;
    }
    function registerTopic({ config, session, topic, existingHandlers, handlers }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let registerResults = [];
        const { toCreate, toUpdate, toDelete } = categorizeHandlers(config, existingHandlers, handlers);
        const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
        const client = new GraphqlClient({ session });
        let operation = types_2.WebhookOperation.Create;
        registerResults = registerResults.concat(yield runMutations({ config, client, topic, operation, handlers: toCreate }));
        operation = types_2.WebhookOperation.Update;
        registerResults = registerResults.concat(yield runMutations({ config, client, topic, operation, handlers: toUpdate }));
        operation = types_2.WebhookOperation.Delete;
        registerResults = registerResults.concat(yield runMutations({ config, client, topic, operation, handlers: toDelete }));
        return registerResults;
      });
    }
    function categorizeHandlers(config, existingHandlers, handlers) {
      const handlersByKey = handlers.reduce((acc, value) => {
        acc[(0, registry_1.handlerIdentifier)(config, value)] = value;
        return acc;
      }, {});
      const existingHandlersByKey = existingHandlers.reduce((acc, value) => {
        acc[(0, registry_1.handlerIdentifier)(config, value)] = value;
        return acc;
      }, {});
      const toCreate = Object.assign({}, handlersByKey);
      const toUpdate = {};
      const toDelete = {};
      for (const existingKey in existingHandlersByKey) {
        if (!Object.prototype.hasOwnProperty.call(existingHandlersByKey, existingKey)) {
          continue;
        }
        const existingHandler = existingHandlersByKey[existingKey];
        const handler = handlersByKey[existingKey];
        if (existingKey in handlersByKey) {
          delete toCreate[existingKey];
          if (!areHandlerFieldsEqual(existingHandler, handler)) {
            toUpdate[existingKey] = handler;
            toUpdate[existingKey].id = existingHandler.id;
          }
        } else {
          toDelete[existingKey] = existingHandler;
        }
      }
      return {
        toCreate: Object.values(toCreate),
        toUpdate: Object.values(toUpdate),
        toDelete: Object.values(toDelete)
      };
    }
    function areHandlerFieldsEqual(arr1, arr2) {
      const includeFieldsEqual = arraysEqual(arr1.includeFields || [], arr2.includeFields || []);
      const metafieldNamespacesEqual = arraysEqual(arr1.metafieldNamespaces || [], arr2.metafieldNamespaces || []);
      return includeFieldsEqual && metafieldNamespacesEqual;
    }
    function arraysEqual(arr1, arr2) {
      if (arr1.length !== arr2.length) {
        return false;
      }
      for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
          return false;
        }
      }
      return true;
    }
    function runMutations({ config, client, topic, handlers, operation }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const registerResults = [];
        for (const handler of handlers) {
          registerResults.push(yield runMutation({ config, client, topic, handler, operation }));
        }
        return registerResults;
      });
    }
    function runMutation({ config, client, topic, handler, operation }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let registerResult;
        (0, logger_1.logger)(config).debug(`Running webhook mutation`, { topic, operation });
        try {
          const query = buildMutation(config, topic, handler, operation);
          const result = yield client.request(query);
          registerResult = {
            deliveryMethod: handler.deliveryMethod,
            success: isSuccess(result, handler, operation),
            result,
            operation
          };
        } catch (error) {
          if (error instanceof error_1.InvalidDeliveryMethodError) {
            registerResult = {
              deliveryMethod: handler.deliveryMethod,
              success: false,
              result: { message: error.message },
              operation
            };
          } else {
            throw error;
          }
        }
        return registerResult;
      });
    }
    function buildMutation(config, topic, handler, operation) {
      const params = {};
      let identifier;
      if (handler.id) {
        identifier = `id: "${handler.id}"`;
      } else {
        identifier = `topic: ${topic}`;
      }
      const mutationArguments = {
        MUTATION_NAME: getMutationName(handler, operation),
        IDENTIFIER: identifier,
        MUTATION_PARAMS: ""
      };
      if (operation !== types_2.WebhookOperation.Delete) {
        switch (handler.deliveryMethod) {
          case types_2.DeliveryMethod.Http:
            params.callbackUrl = `"${(0, registry_1.addHostToCallbackUrl)(config, handler.callbackUrl)}"`;
            break;
          case types_2.DeliveryMethod.EventBridge:
            params.arn = `"${handler.arn}"`;
            break;
          case types_2.DeliveryMethod.PubSub:
            params.pubSubProject = `"${handler.pubSubProject}"`;
            params.pubSubTopic = `"${handler.pubSubTopic}"`;
            break;
          default:
            throw new error_1.InvalidDeliveryMethodError(`Unrecognized delivery method '${handler.deliveryMethod}'`);
        }
        if (handler.includeFields) {
          params.includeFields = JSON.stringify(handler.includeFields);
        }
        if (handler.metafieldNamespaces) {
          params.metafieldNamespaces = JSON.stringify(handler.metafieldNamespaces);
        }
        if (handler.subTopic) {
          const subTopicString = `subTopic: "${handler.subTopic}",`;
          mutationArguments.MUTATION_PARAMS = subTopicString;
        }
        const paramsString = Object.entries(params).map(([key, value]) => `${key}: ${value}`).join(", ");
        mutationArguments.MUTATION_PARAMS += `webhookSubscription: {${paramsString}}`;
      }
      return (0, query_template_1.queryTemplate)(exports.TEMPLATE_MUTATION, mutationArguments);
    }
    function getMutationName(handler, operation) {
      switch (operation) {
        case types_2.WebhookOperation.Create:
          return `${getEndpoint(handler)}Create`;
        case types_2.WebhookOperation.Update:
          return `${getEndpoint(handler)}Update`;
        case types_2.WebhookOperation.Delete:
          return "webhookSubscriptionDelete";
        default:
          throw new error_1.ShopifyError(`Unrecognized operation '${operation}'`);
      }
    }
    function getEndpoint(handler) {
      switch (handler.deliveryMethod) {
        case types_2.DeliveryMethod.Http:
          return "webhookSubscription";
        case types_2.DeliveryMethod.EventBridge:
          return "eventBridgeWebhookSubscription";
        case types_2.DeliveryMethod.PubSub:
          return "pubSubWebhookSubscription";
        default:
          throw new error_1.ShopifyError(`Unrecognized delivery method '${handler.deliveryMethod}'`);
      }
    }
    function isSuccess(result, handler, operation) {
      const mutationName = getMutationName(handler, operation);
      return Boolean(result.data && result.data[mutationName] && result.data[mutationName].userErrors.length === 0);
    }
    exports.TEMPLATE_GET_HANDLERS = `query shopifyApiReadWebhookSubscriptions {
  webhookSubscriptions(
    first: 250,
    after: {{END_CURSOR}},
  ) {
    edges {
      node {
        id
        topic
        includeFields
        metafieldNamespaces
        endpoint {
          __typename
          ... on WebhookHttpEndpoint {
            callbackUrl
          }
          ... on WebhookEventBridgeEndpoint {
            arn
          }
          ... on WebhookPubSubEndpoint {
            pubSubProject
            pubSubTopic
          }
        }
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}`;
    exports.TEMPLATE_MUTATION = `
  mutation shopifyApiCreateWebhookSubscription {
    {{MUTATION_NAME}}(
      {{IDENTIFIER}},
      {{MUTATION_PARAMS}}
    ) {
      userErrors {
        field
        message
      }
    }
  }
`;
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/validate.js
var require_validate2 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateFactory = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var http_1 = require_http();
    var types_1 = require_types2();
    var logger_1 = require_logger();
    var hmac_validator_1 = require_hmac_validator();
    var runtime_1 = require_runtime();
    var types_2 = require_types5();
    var registry_1 = require_registry();
    var OPTIONAL_HANDLER_PROPERTIES = {
      subTopic: types_1.ShopifyHeader.SubTopic
    };
    var HANDLER_PROPERTIES = Object.assign({ apiVersion: types_1.ShopifyHeader.ApiVersion, domain: types_1.ShopifyHeader.Domain, hmac: types_1.ShopifyHeader.Hmac, topic: types_1.ShopifyHeader.Topic, webhookId: types_1.ShopifyHeader.WebhookId }, OPTIONAL_HANDLER_PROPERTIES);
    function validateFactory(config) {
      return function validate(_a2) {
        var { rawBody } = _a2, adapterArgs = tslib_1.__rest(_a2, ["rawBody"]);
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const request = yield (0, http_1.abstractConvertRequest)(adapterArgs);
          const log = (0, logger_1.logger)(config);
          const webhookCheck = checkWebhookRequest(rawBody, request.headers);
          if (!webhookCheck.valid) {
            yield log.debug("Received malformed webhook request", webhookCheck);
            return webhookCheck;
          }
          const { hmac, valid: _valid } = webhookCheck, loggingContext = tslib_1.__rest(webhookCheck, ["hmac", "valid"]);
          yield log.debug("Webhook request is well formed", loggingContext);
          if (yield (0, hmac_validator_1.validateHmacString)(config, rawBody, hmac, runtime_1.HashFormat.Base64)) {
            yield log.debug("Webhook request is valid", loggingContext);
            return webhookCheck;
          } else {
            yield log.debug("Webhook HMAC validation failed. Please note that events manually triggered from a store's Notifications settings will fail this validation. To test this, please use the CLI or trigger the actual event in a development store.");
            return {
              valid: false,
              reason: types_2.WebhookValidationErrorReason.InvalidHmac
            };
          }
        });
      };
    }
    exports.validateFactory = validateFactory;
    function checkWebhookRequest(rawBody, headers) {
      if (!rawBody.length) {
        return {
          valid: false,
          reason: types_2.WebhookValidationErrorReason.MissingBody
        };
      }
      const missingHeaders = [];
      const entries = Object.entries(HANDLER_PROPERTIES);
      const headerValues = entries.reduce((acc, [property, headerName]) => {
        const headerValue = (0, http_1.getHeader)(headers, headerName);
        if (headerValue) {
          acc[property] = headerValue;
        } else if (!(property in OPTIONAL_HANDLER_PROPERTIES)) {
          missingHeaders.push(headerName);
        }
        return acc;
      }, {});
      if (missingHeaders.length) {
        return {
          valid: false,
          reason: types_2.WebhookValidationErrorReason.MissingHeaders,
          missingHeaders
        };
      } else {
        return Object.assign(Object.assign(Object.assign({ valid: true }, headerValues), headerValues.subTopic ? { subTopic: headerValues.subTopic } : {}), { topic: (0, registry_1.topicForStorage)(headerValues.topic) });
      }
    }
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/process.js
var require_process = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/process.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.process = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var network_1 = require_network();
    var http_1 = require_http();
    var ShopifyErrors = tslib_1.__importStar(require_error());
    var logger_1 = require_logger();
    var types_1 = require_types5();
    var validate_1 = require_validate2();
    var STATUS_TEXT_LOOKUP = {
      [network_1.StatusCode.Ok]: "OK",
      [network_1.StatusCode.BadRequest]: "Bad Request",
      [network_1.StatusCode.Unauthorized]: "Unauthorized",
      [network_1.StatusCode.NotFound]: "Not Found",
      [network_1.StatusCode.InternalServerError]: "Internal Server Error"
    };
    function process(config, webhookRegistry) {
      return function process2(_a2) {
        var { rawBody } = _a2, adapterArgs = tslib_1.__rest(_a2, ["rawBody"]);
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const response = {
            statusCode: network_1.StatusCode.Ok,
            statusText: STATUS_TEXT_LOOKUP[network_1.StatusCode.Ok],
            headers: {}
          };
          yield (0, logger_1.logger)(config).info("Receiving webhook request");
          const webhookCheck = yield (0, validate_1.validateFactory)(config)(Object.assign({ rawBody }, adapterArgs));
          let errorMessage = "Unknown error while handling webhook";
          if (webhookCheck.valid) {
            const handlerResult = yield callWebhookHandlers(config, webhookRegistry, webhookCheck, rawBody);
            response.statusCode = handlerResult.statusCode;
            if (!(0, http_1.isOK)(response)) {
              errorMessage = handlerResult.errorMessage || errorMessage;
            }
          } else {
            const errorResult = yield handleInvalidWebhook(config, webhookCheck);
            response.statusCode = errorResult.statusCode;
            response.statusText = STATUS_TEXT_LOOKUP[response.statusCode];
            errorMessage = errorResult.errorMessage;
          }
          const returnResponse = yield (0, http_1.abstractConvertResponse)(response, adapterArgs);
          if (!(0, http_1.isOK)(response)) {
            throw new ShopifyErrors.InvalidWebhookError({
              message: errorMessage,
              response: returnResponse
            });
          }
          return Promise.resolve(returnResponse);
        });
      };
    }
    exports.process = process;
    function callWebhookHandlers(config, webhookRegistry, webhookCheck, rawBody) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const log = (0, logger_1.logger)(config);
        const { hmac: _hmac, valid: _valid } = webhookCheck, loggingContext = tslib_1.__rest(webhookCheck, ["hmac", "valid"]);
        yield log.debug("Webhook request is valid, looking for HTTP handlers to call", loggingContext);
        const handlers = webhookRegistry[webhookCheck.topic] || [];
        const response = { statusCode: network_1.StatusCode.Ok };
        let found = false;
        for (const handler of handlers) {
          if (handler.deliveryMethod !== types_1.DeliveryMethod.Http) {
            continue;
          }
          if (!handler.callback) {
            response.statusCode = network_1.StatusCode.InternalServerError;
            response.errorMessage = "Cannot call webhooks.process with a webhook handler that doesn't have a callback";
            throw new ShopifyErrors.MissingWebhookCallbackError({
              message: response.errorMessage,
              response
            });
          }
          found = true;
          yield log.debug("Found HTTP handler, triggering it", loggingContext);
          try {
            yield handler.callback(webhookCheck.topic, webhookCheck.domain, rawBody, webhookCheck.webhookId, webhookCheck.apiVersion, ...(webhookCheck === null || webhookCheck === void 0 ? void 0 : webhookCheck.subTopic) ? webhookCheck.subTopic : "");
          } catch (error) {
            response.statusCode = network_1.StatusCode.InternalServerError;
            response.errorMessage = error.message;
          }
        }
        if (!found) {
          yield log.debug("No HTTP handlers found", loggingContext);
          response.statusCode = network_1.StatusCode.NotFound;
          response.errorMessage = `No HTTP webhooks registered for topic ${webhookCheck.topic}`;
        }
        return response;
      });
    }
    function handleInvalidWebhook(config, webhookCheck) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const response = {
          statusCode: network_1.StatusCode.InternalServerError,
          errorMessage: "Unknown error while handling webhook"
        };
        switch (webhookCheck.reason) {
          case types_1.WebhookValidationErrorReason.MissingHeaders:
            response.statusCode = network_1.StatusCode.BadRequest;
            response.errorMessage = `Missing one or more of the required HTTP headers to process webhooks: [${webhookCheck.missingHeaders.join(", ")}]`;
            break;
          case types_1.WebhookValidationErrorReason.MissingBody:
            response.statusCode = network_1.StatusCode.BadRequest;
            response.errorMessage = "No body was received when processing webhook";
            break;
          case types_1.WebhookValidationErrorReason.InvalidHmac:
            response.statusCode = network_1.StatusCode.Unauthorized;
            response.errorMessage = `Could not validate request HMAC`;
            break;
        }
        yield (0, logger_1.logger)(config).debug(`Webhook request is invalid, returning ${response.statusCode}: ${response.errorMessage}`);
        return response;
      });
    }
  }
});

// node_modules/@shopify/shopify-api/lib/webhooks/index.js
var require_webhooks = __commonJS({
  "node_modules/@shopify/shopify-api/lib/webhooks/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyWebhooks = void 0;
    var registry_1 = require_registry();
    var register_1 = require_register();
    var process_1 = require_process();
    var validate_1 = require_validate2();
    function shopifyWebhooks(config) {
      const webhookRegistry = (0, registry_1.registry)();
      return {
        addHandlers: (0, registry_1.addHandlers)(config, webhookRegistry),
        getTopicsAdded: (0, registry_1.getTopicsAdded)(webhookRegistry),
        getHandlers: (0, registry_1.getHandlers)(webhookRegistry),
        register: (0, register_1.register)(config, webhookRegistry),
        process: (0, process_1.process)(config, webhookRegistry),
        validate: (0, validate_1.validateFactory)(config)
      };
    }
    exports.shopifyWebhooks = shopifyWebhooks;
  }
});

// node_modules/@shopify/shopify-api/lib/billing/check.js
var require_check = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/check.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.check = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var admin_1 = require_admin();
    var error_1 = require_error();
    function check2(config) {
      return function check3({ session, plans, isTest = true, returnObject = false }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!config.billing) {
            throw new error_1.BillingError({
              message: "Attempted to look for purchases without billing configs",
              errorData: []
            });
          }
          const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
          const client = new GraphqlClient({ session });
          const plansArray = Array.isArray(plans) ? plans : [plans];
          return assessPayments({
            plans: plansArray,
            client,
            isTest,
            returnObject
          });
        });
      };
    }
    exports.check = check2;
    function assessPayments({ plans, client, isTest, returnObject }) {
      var _a2;
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const returnValue = returnObject ? {
          hasActivePayment: false,
          oneTimePurchases: [],
          appSubscriptions: []
        } : false;
        let installation;
        let endCursor = null;
        do {
          const currentInstallations = yield client.request(HAS_PAYMENTS_QUERY, { variables: { endCursor } });
          installation = (_a2 = currentInstallations.data) === null || _a2 === void 0 ? void 0 : _a2.currentAppInstallation;
          if (returnObject) {
            installation.activeSubscriptions.map((subscription) => {
              if (subscriptionMeetsCriteria({ plans, isTest, subscription })) {
                returnValue.hasActivePayment = true;
                returnValue.appSubscriptions.push(subscription);
              }
            });
            installation.oneTimePurchases.edges.map((purchase) => {
              if (purchaseMeetsCriteria({ plans, isTest, purchase: purchase.node })) {
                returnValue.hasActivePayment = true;
                returnValue.oneTimePurchases.push(purchase.node);
              }
            });
          } else {
            const params = { plans, isTest, installation };
            if (hasSubscription(params) || hasOneTimePayment(params)) {
              return true;
            }
          }
          endCursor = installation.oneTimePurchases.pageInfo.endCursor;
        } while (installation === null || installation === void 0 ? void 0 : installation.oneTimePurchases.pageInfo.hasNextPage);
        return returnValue;
      });
    }
    function subscriptionMeetsCriteria({ plans, isTest, subscription }) {
      return plans.includes(subscription.name) && (isTest || !subscription.test);
    }
    function purchaseMeetsCriteria({ plans, isTest, purchase }) {
      return plans.includes(purchase.name) && (isTest || !purchase.test) && purchase.status === "ACTIVE";
    }
    function hasSubscription({ plans, isTest, installation }) {
      return installation.activeSubscriptions.some((subscription) => subscriptionMeetsCriteria({ plans, isTest, subscription }));
    }
    function hasOneTimePayment({ plans, isTest, installation }) {
      return installation.oneTimePurchases.edges.some((purchase) => purchaseMeetsCriteria({ plans, isTest, purchase: purchase.node }));
    }
    var HAS_PAYMENTS_QUERY = `
  query appSubscription($endCursor: String) {
    currentAppInstallation {
      activeSubscriptions {
        id
        name
        test
        lineItems {
          id
          plan {
            pricingDetails {
              ... on AppRecurringPricing {
                price {
                  amount
                  currencyCode
                }
                interval
                discount {
                  durationLimitInIntervals
                  remainingDurationInIntervals
                  priceAfterDiscount {
                    amount
                  }
                  value {
                    ... on AppSubscriptionDiscountAmount {
                      amount {
                        amount
                        currencyCode
                      }
                    }
                    ... on AppSubscriptionDiscountPercentage {
                      percentage
                    }
                  }
                }
              }
              ... on AppUsagePricing {
                balanceUsed {
                  amount
                  currencyCode
                }
                cappedAmount {
                  amount
                  currencyCode
                }
                terms
              }
            }
          }
        }
      }
      oneTimePurchases(first: 250, sortKey: CREATED_AT, after: $endCursor) {
        edges {
          node {
            id
            name
            test
            status
          }
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
  }
`;
  }
});

// node_modules/@shopify/shopify-api/lib/billing/request.js
var require_request = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.request = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var types_1 = require_types2();
    var error_1 = require_error();
    var get_embedded_app_url_1 = require_get_embedded_app_url();
    var admin_1 = require_admin();
    var crypto_1 = require_crypto();
    var types_2 = require_types();
    function request(config) {
      return function(_a2) {
        var _b2;
        var { session, plan, isTest = true, returnUrl: returnUrlParam, returnObject = false } = _a2, overrides = tslib_1.__rest(_a2, ["session", "plan", "isTest", "returnUrl", "returnObject"]);
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!config.billing || !config.billing[plan]) {
            throw new error_1.BillingError({
              message: `Could not find plan ${plan} in billing settings`,
              errorData: []
            });
          }
          const billingConfig = Object.assign({}, config.billing[plan]);
          const filteredOverrides = Object.fromEntries(Object.entries(overrides).filter(([_key, value]) => value !== void 0));
          const cleanShopName = session.shop.replace(".myshopify.com", "");
          const embeddedAppUrl = (0, get_embedded_app_url_1.buildEmbeddedAppUrl)(config)((0, crypto_1.hashString)(`admin.shopify.com/store/${cleanShopName}`, types_2.HashFormat.Base64));
          const appUrl = `${config.hostScheme}://${config.hostName}?shop=${session.shop}`;
          const returnUrl = returnUrlParam || (config.isEmbeddedApp ? embeddedAppUrl : appUrl);
          const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
          const client = new GraphqlClient({ session });
          function isLineItemPlan(billingConfig2) {
            return "lineItems" in billingConfig2;
          }
          function isOneTimePlan(billingConfig2) {
            return billingConfig2.interval === types_1.BillingInterval.OneTime;
          }
          let data;
          if (isLineItemPlan(billingConfig)) {
            const mergedBillingConfigs = mergeBillingConfigs(billingConfig, filteredOverrides);
            const mutationRecurringResponse = yield requestSubscriptionPayment({
              billingConfig: mergedBillingConfigs,
              plan,
              client,
              returnUrl,
              isTest
            });
            data = mutationRecurringResponse.appSubscriptionCreate;
          } else if (isOneTimePlan(billingConfig)) {
            const mutationOneTimeResponse = yield requestSinglePayment({
              billingConfig: Object.assign(Object.assign({}, billingConfig), filteredOverrides),
              plan,
              client,
              returnUrl,
              isTest
            });
            data = mutationOneTimeResponse.appPurchaseOneTimeCreate;
          } else {
            switch (billingConfig.interval) {
              case types_1.BillingInterval.Usage: {
                const mutationUsageResponse = yield requestUsagePayment({
                  billingConfig: Object.assign(Object.assign({}, billingConfig), filteredOverrides),
                  plan,
                  client,
                  returnUrl,
                  isTest
                });
                data = mutationUsageResponse.appSubscriptionCreate;
                break;
              }
              default: {
                const mutationRecurringResponse = yield requestRecurringPayment({
                  billingConfig: Object.assign(Object.assign({}, billingConfig), filteredOverrides),
                  plan,
                  client,
                  returnUrl,
                  isTest
                });
                data = mutationRecurringResponse.appSubscriptionCreate;
              }
            }
          }
          if ((_b2 = data.userErrors) === null || _b2 === void 0 ? void 0 : _b2.length) {
            throw new error_1.BillingError({
              message: "Error while billing the store",
              errorData: data.userErrors
            });
          }
          if (returnObject) {
            return data;
          } else {
            return data.confirmationUrl;
          }
        });
      };
    }
    exports.request = request;
    function requestSubscriptionPayment({ billingConfig, plan, client, returnUrl, isTest }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const lineItems = billingConfig.lineItems.map((item) => {
          if (item.interval === types_1.BillingInterval.Every30Days || item.interval === types_1.BillingInterval.Annual) {
            const appRecurringPricingDetails = {
              interval: item.interval,
              price: {
                amount: item.amount,
                currencyCode: item.currencyCode
              }
            };
            if (item.discount) {
              appRecurringPricingDetails.discount = {
                durationLimitInIntervals: item.discount.durationLimitInIntervals,
                value: {
                  amount: item.discount.value.amount,
                  percentage: item.discount.value.percentage
                }
              };
            }
            return {
              plan: {
                appRecurringPricingDetails
              }
            };
          } else if (item.interval === types_1.BillingInterval.Usage) {
            const appUsagePricingDetails = {
              terms: item.terms,
              cappedAmount: {
                amount: item.amount,
                currencyCode: item.currencyCode
              }
            };
            return {
              plan: {
                appUsagePricingDetails
              }
            };
          } else {
            throw new error_1.BillingError({
              message: "Invalid interval provided",
              errorData: [item]
            });
          }
        });
        const mutationResponse = yield client.request(RECURRING_PURCHASE_MUTATION, {
          variables: {
            name: plan,
            trialDays: billingConfig.trialDays,
            replacementBehavior: billingConfig.replacementBehavior,
            returnUrl,
            test: isTest,
            lineItems
          }
        });
        if (mutationResponse.errors) {
          throw new error_1.BillingError({
            message: "Error while billing the store",
            errorData: mutationResponse.errors
          });
        }
        return mutationResponse.data;
      });
    }
    function requestRecurringPayment({ billingConfig, plan, client, returnUrl, isTest }) {
      var _a2, _b2, _c, _d, _e;
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const mutationResponse = yield client.request(RECURRING_PURCHASE_MUTATION, {
          variables: {
            name: plan,
            trialDays: billingConfig.trialDays,
            replacementBehavior: billingConfig.replacementBehavior,
            returnUrl,
            test: isTest,
            lineItems: [
              {
                plan: {
                  appRecurringPricingDetails: {
                    interval: billingConfig.interval,
                    price: {
                      amount: billingConfig.amount,
                      currencyCode: billingConfig.currencyCode
                    },
                    discount: {
                      durationLimitInIntervals: (_a2 = billingConfig.discount) === null || _a2 === void 0 ? void 0 : _a2.durationLimitInIntervals,
                      value: {
                        amount: (_c = (_b2 = billingConfig.discount) === null || _b2 === void 0 ? void 0 : _b2.value) === null || _c === void 0 ? void 0 : _c.amount,
                        percentage: (_e = (_d = billingConfig.discount) === null || _d === void 0 ? void 0 : _d.value) === null || _e === void 0 ? void 0 : _e.percentage
                      }
                    }
                  }
                }
              }
            ]
          }
        });
        if (mutationResponse.errors) {
          throw new error_1.BillingError({
            message: "Error while billing the store",
            errorData: mutationResponse.errors
          });
        }
        return mutationResponse.data;
      });
    }
    function requestUsagePayment({ billingConfig, plan, client, returnUrl, isTest }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const mutationResponse = yield client.request(RECURRING_PURCHASE_MUTATION, {
          variables: {
            name: plan,
            returnUrl,
            test: isTest,
            trialDays: billingConfig.trialDays,
            replacementBehavior: billingConfig.replacementBehavior,
            lineItems: [
              {
                plan: {
                  appUsagePricingDetails: {
                    terms: billingConfig.usageTerms,
                    cappedAmount: {
                      amount: billingConfig.amount,
                      currencyCode: billingConfig.currencyCode
                    }
                  }
                }
              }
            ]
          }
        });
        if (mutationResponse.errors) {
          throw new error_1.BillingError({
            message: `Error while billing the store:: ${mutationResponse.errors}`,
            errorData: mutationResponse.errors
          });
        }
        return mutationResponse.data;
      });
    }
    function requestSinglePayment({ billingConfig, plan, client, returnUrl, isTest }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const mutationResponse = yield client.request(ONE_TIME_PURCHASE_MUTATION, {
          variables: {
            name: plan,
            returnUrl,
            test: isTest,
            price: {
              amount: billingConfig.amount,
              currencyCode: billingConfig.currencyCode
            }
          }
        });
        if (mutationResponse.errors) {
          throw new error_1.BillingError({
            message: "Error while billing the store",
            errorData: mutationResponse.errors
          });
        }
        return mutationResponse.data;
      });
    }
    function mergeBillingConfigs(billingConfig, overrides) {
      const mergedConfig = Object.assign(Object.assign({}, billingConfig), overrides);
      const mergedLineItems = [];
      if (billingConfig.lineItems && overrides.lineItems) {
        for (const i of billingConfig.lineItems) {
          let found = false;
          for (const j of overrides.lineItems) {
            if (i.interval === j.interval) {
              mergedLineItems.push(Object.assign(Object.assign({}, i), j));
              found = true;
              break;
            }
          }
          if (!found) {
            mergedLineItems.push(i);
          }
        }
        mergedConfig.lineItems = mergedLineItems;
      }
      return mergedConfig;
    }
    var RECURRING_PURCHASE_MUTATION = `
  mutation test(
    $name: String!
    $lineItems: [AppSubscriptionLineItemInput!]!
    $returnUrl: URL!
    $test: Boolean
    $trialDays: Int
    $replacementBehavior: AppSubscriptionReplacementBehavior
  ) {
    appSubscriptionCreate(
      name: $name
      lineItems: $lineItems
      returnUrl: $returnUrl
      test: $test
      trialDays: $trialDays
      replacementBehavior: $replacementBehavior
    ) {
      appSubscription {
        id
        name
        test
      }
      confirmationUrl
      userErrors {
        field
        message
      }
    }
  }
`;
    var ONE_TIME_PURCHASE_MUTATION = `
  mutation test(
    $name: String!
    $price: MoneyInput!
    $returnUrl: URL!
    $test: Boolean
  ) {
    appPurchaseOneTimeCreate(
      name: $name
      price: $price
      returnUrl: $returnUrl
      test: $test
    ) {
      appPurchaseOneTime {
        id
        name
        test
      }
      confirmationUrl
      userErrors {
        field
        message
      }
    }
  }
`;
  }
});

// node_modules/@shopify/shopify-api/lib/billing/cancel.js
var require_cancel = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/cancel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cancel = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var admin_1 = require_admin();
    var error_1 = require_error();
    var CANCEL_MUTATION = `
  mutation appSubscriptionCancel($id: ID!, $prorate: Boolean) {
    appSubscriptionCancel(id: $id, prorate: $prorate) {
      appSubscription {
        id
        name
        test
      }
      userErrors {
        field
        message
      }
    }
  }
`;
    function cancel(config) {
      return function(subscriptionInfo) {
        var _a2, _b2, _c, _d, _e, _f, _g;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { session, subscriptionId, prorate = true } = subscriptionInfo;
          const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
          const client = new GraphqlClient({ session });
          try {
            const response = yield client.request(CANCEL_MUTATION, {
              variables: { id: subscriptionId, prorate }
            });
            if ((_b2 = (_a2 = response.data) === null || _a2 === void 0 ? void 0 : _a2.appSubscriptionCancel) === null || _b2 === void 0 ? void 0 : _b2.userErrors.length) {
              throw new error_1.BillingError({
                message: "Error while canceling a subscription",
                errorData: (_d = (_c = response.data) === null || _c === void 0 ? void 0 : _c.appSubscriptionCancel) === null || _d === void 0 ? void 0 : _d.userErrors
              });
            }
            return (_f = (_e = response.data) === null || _e === void 0 ? void 0 : _e.appSubscriptionCancel) === null || _f === void 0 ? void 0 : _f.appSubscription;
          } catch (error) {
            if (error instanceof error_1.GraphqlQueryError) {
              throw new error_1.BillingError({
                message: error.message,
                errorData: (_g = error.response) === null || _g === void 0 ? void 0 : _g.errors
              });
            } else {
              throw error;
            }
          }
        });
      };
    }
    exports.cancel = cancel;
  }
});

// node_modules/@shopify/shopify-api/lib/billing/subscriptions.js
var require_subscriptions = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/subscriptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subscriptions = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var error_1 = require_error();
    var admin_1 = require_admin();
    var SUBSCRIPTION_QUERY = `
query appSubscription {
  currentAppInstallation {
    activeSubscriptions {
      id
      name
      test
      lineItems {
        id
        plan {
          pricingDetails {
            ... on AppRecurringPricing {
              price {
                amount
                currencyCode
              }
              interval
              discount {
                durationLimitInIntervals
                remainingDurationInIntervals
                priceAfterDiscount {
                  amount
                }
                value {
                  ... on AppSubscriptionDiscountAmount {
                    amount {
                      amount
                      currencyCode
                    }
                  }
                  ... on AppSubscriptionDiscountPercentage {
                    percentage
                  }
                }
              }
            }
            ... on AppUsagePricing {
              balanceUsed {
                amount
                currencyCode
              }
              cappedAmount {
                amount
                currencyCode
              }
              terms
            }
          }
        }
      }
    }
  }
}
`;
    function subscriptions(config) {
      return function({ session }) {
        var _a2;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!config.billing) {
            throw new error_1.BillingError({
              message: "Attempted to look for purchases without billing configs",
              errorData: []
            });
          }
          const GraphqlClient = (0, admin_1.graphqlClientClass)({ config });
          const client = new GraphqlClient({ session });
          const response = yield client.request(SUBSCRIPTION_QUERY);
          return (_a2 = response.data) === null || _a2 === void 0 ? void 0 : _a2.currentAppInstallation;
        });
      };
    }
    exports.subscriptions = subscriptions;
  }
});

// node_modules/@shopify/shopify-api/lib/billing/index.js
var require_billing = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyBilling = void 0;
    var check_1 = require_check();
    var request_1 = require_request();
    var cancel_1 = require_cancel();
    var subscriptions_1 = require_subscriptions();
    function shopifyBilling(config) {
      return {
        check: (0, check_1.check)(config),
        request: (0, request_1.request)(config),
        cancel: (0, cancel_1.cancel)(config),
        subscriptions: (0, subscriptions_1.subscriptions)(config)
      };
    }
    exports.shopifyBilling = shopifyBilling;
  }
});

// node_modules/@shopify/shopify-api/lib/flow/types.js
var require_types6 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/flow/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FlowValidationErrorReason = void 0;
    var FlowValidationErrorReason;
    (function(FlowValidationErrorReason2) {
      FlowValidationErrorReason2["MissingBody"] = "missing_body";
      FlowValidationErrorReason2["MissingHmac"] = "missing_hmac";
      FlowValidationErrorReason2["InvalidHmac"] = "invalid_hmac";
    })(FlowValidationErrorReason || (exports.FlowValidationErrorReason = FlowValidationErrorReason = {}));
  }
});

// node_modules/@shopify/shopify-api/lib/flow/validate.js
var require_validate3 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/flow/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateFactory = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var http_1 = require_http();
    var types_1 = require_types();
    var logger_1 = require_logger();
    var types_2 = require_types2();
    var hmac_validator_1 = require_hmac_validator();
    var types_3 = require_types6();
    function validateFactory(config) {
      return function validate(_a2) {
        var { rawBody } = _a2, adapterArgs = tslib_1.__rest(_a2, ["rawBody"]);
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const request = yield (0, http_1.abstractConvertRequest)(adapterArgs);
          if (!rawBody.length) {
            return fail(types_3.FlowValidationErrorReason.MissingBody, config);
          }
          const hmac = (0, http_1.getHeader)(request.headers, types_2.ShopifyHeader.Hmac);
          if (!hmac) {
            return fail(types_3.FlowValidationErrorReason.MissingHmac, config);
          }
          if (yield (0, hmac_validator_1.validateHmacString)(config, rawBody, hmac, types_1.HashFormat.Base64)) {
            return succeed(config);
          }
          return fail(types_3.FlowValidationErrorReason.InvalidHmac, config);
        });
      };
    }
    exports.validateFactory = validateFactory;
    function fail(reason, config) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const log = (0, logger_1.logger)(config);
        yield log.debug("Flow request is not valid", { reason });
        return {
          valid: false,
          reason
        };
      });
    }
    function succeed(config) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const log = (0, logger_1.logger)(config);
        yield log.debug("Flow request is valid");
        return {
          valid: true
        };
      });
    }
  }
});

// node_modules/@shopify/shopify-api/lib/flow/index.js
var require_flow = __commonJS({
  "node_modules/@shopify/shopify-api/lib/flow/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyFlow = void 0;
    var validate_1 = require_validate3();
    function shopifyFlow(config) {
      return {
        validate: (0, validate_1.validateFactory)(config)
      };
    }
    exports.shopifyFlow = shopifyFlow;
  }
});

// node_modules/@shopify/shopify-api/lib/session/classes.js
var require_classes = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Session = void 0;
    var session_1 = require_session();
    Object.defineProperty(exports, "Session", { enumerable: true, get: function() {
      return session_1.Session;
    } });
  }
});

// node_modules/@shopify/shopify-api/rest/types.js
var require_types7 = __commonJS({
  "node_modules/@shopify/shopify-api/rest/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@shopify/shopify-api/lib/base-types.js
var require_base_types = __commonJS({
  "node_modules/@shopify/shopify-api/lib/base-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@shopify/shopify-api/lib/auth/types.js
var require_types8 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/auth/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestedTokenType = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_types4(), exports);
    var token_exchange_1 = require_token_exchange();
    Object.defineProperty(exports, "RequestedTokenType", { enumerable: true, get: function() {
      return token_exchange_1.RequestedTokenType;
    } });
  }
});

// node_modules/@shopify/shopify-api/lib/billing/types.js
var require_types9 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/billing/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@shopify/shopify-api/lib/session/types.js
var require_types10 = __commonJS({
  "node_modules/@shopify/shopify-api/lib/session/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@shopify/shopify-api/lib/index.js
var require_lib = __commonJS({
  "node_modules/@shopify/shopify-api/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shopifyApi = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var load_rest_resources_1 = require_load_rest_resources();
    var platform_1 = require_platform();
    var config_1 = require_config();
    var clients_1 = require_clients();
    var auth_1 = require_auth();
    var session_1 = require_session2();
    var utils_1 = require_utils();
    var webhooks_1 = require_webhooks();
    var billing_1 = require_billing();
    var logger_1 = require_logger();
    var version_1 = require_version();
    var client_1 = require_client2();
    var flow_1 = require_flow();
    tslib_1.__exportStar(require_error(), exports);
    tslib_1.__exportStar(require_classes(), exports);
    tslib_1.__exportStar(require_types7(), exports);
    tslib_1.__exportStar(require_types2(), exports);
    tslib_1.__exportStar(require_base_types(), exports);
    tslib_1.__exportStar(require_types8(), exports);
    tslib_1.__exportStar(require_types9(), exports);
    tslib_1.__exportStar(require_types3(), exports);
    tslib_1.__exportStar(require_types10(), exports);
    tslib_1.__exportStar(require_types5(), exports);
    tslib_1.__exportStar(require_types6(), exports);
    function shopifyApi(_a2) {
      var { future, restResources } = _a2, config = tslib_1.__rest(_a2, ["future", "restResources"]);
      const libConfig = Object.assign(Object.assign({}, config), { future, restResources });
      const validatedConfig = (0, config_1.validateConfig)(libConfig);
      const shopify = {
        config: validatedConfig,
        clients: (0, clients_1.clientClasses)(validatedConfig),
        auth: (0, auth_1.shopifyAuth)(validatedConfig),
        session: (0, session_1.shopifySession)(validatedConfig),
        utils: (0, utils_1.shopifyUtils)(validatedConfig),
        webhooks: (0, webhooks_1.shopifyWebhooks)(validatedConfig),
        billing: (0, billing_1.shopifyBilling)(validatedConfig),
        flow: (0, flow_1.shopifyFlow)(validatedConfig),
        logger: (0, logger_1.logger)(validatedConfig),
        rest: {}
      };
      if (restResources) {
        shopify.rest = (0, load_rest_resources_1.loadRestResources)({
          resources: restResources,
          config: validatedConfig,
          RestClient: (0, client_1.restClientClass)({ config: validatedConfig })
        });
      }
      shopify.logger.info(`version ${version_1.SHOPIFY_API_LIBRARY_VERSION}, environment ${(0, platform_1.abstractRuntimeString)()}`).catch((err) => console.log(err));
      return shopify;
    }
    exports.shopifyApi = shopifyApi;
  }
});

export {
  require_lib
};
//# sourceMappingURL=chunk-IS3H2M7T.js.map
