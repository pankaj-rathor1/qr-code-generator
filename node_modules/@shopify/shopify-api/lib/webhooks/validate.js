"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFactory = void 0;
const tslib_1 = require("tslib");
const http_1 = require("../../runtime/http");
const types_1 = require("../types");
const logger_1 = require("../logger");
const hmac_validator_1 = require("../utils/hmac-validator");
const runtime_1 = require("../../runtime");
const types_2 = require("./types");
const registry_1 = require("./registry");
const OPTIONAL_HANDLER_PROPERTIES = {
    subTopic: types_1.ShopifyHeader.SubTopic,
};
const HANDLER_PROPERTIES = Object.assign({ apiVersion: types_1.ShopifyHeader.ApiVersion, domain: types_1.ShopifyHeader.Domain, hmac: types_1.ShopifyHeader.Hmac, topic: types_1.ShopifyHeader.Topic, webhookId: types_1.ShopifyHeader.WebhookId }, OPTIONAL_HANDLER_PROPERTIES);
function validateFactory(config) {
    return function validate(_a) {
        var { rawBody } = _a, adapterArgs = tslib_1.__rest(_a, ["rawBody"]);
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const request = yield (0, http_1.abstractConvertRequest)(adapterArgs);
            const log = (0, logger_1.logger)(config);
            const webhookCheck = checkWebhookRequest(rawBody, request.headers);
            if (!webhookCheck.valid) {
                yield log.debug('Received malformed webhook request', webhookCheck);
                return webhookCheck;
            }
            const { hmac, valid: _valid } = webhookCheck, loggingContext = tslib_1.__rest(webhookCheck, ["hmac", "valid"]);
            yield log.debug('Webhook request is well formed', loggingContext);
            if (yield (0, hmac_validator_1.validateHmacString)(config, rawBody, hmac, runtime_1.HashFormat.Base64)) {
                yield log.debug('Webhook request is valid', loggingContext);
                return webhookCheck;
            }
            else {
                yield log.debug("Webhook HMAC validation failed. Please note that events manually triggered from a store's Notifications settings will fail this validation. To test this, please use the CLI or trigger the actual event in a development store.");
                return {
                    valid: false,
                    reason: types_2.WebhookValidationErrorReason.InvalidHmac,
                };
            }
        });
    };
}
exports.validateFactory = validateFactory;
function checkWebhookRequest(rawBody, headers) {
    if (!rawBody.length) {
        return {
            valid: false,
            reason: types_2.WebhookValidationErrorReason.MissingBody,
        };
    }
    const missingHeaders = [];
    const entries = Object.entries(HANDLER_PROPERTIES);
    const headerValues = entries.reduce((acc, [property, headerName]) => {
        const headerValue = (0, http_1.getHeader)(headers, headerName);
        if (headerValue) {
            acc[property] = headerValue;
        }
        else if (!(property in OPTIONAL_HANDLER_PROPERTIES)) {
            missingHeaders.push(headerName);
        }
        return acc;
    }, {});
    if (missingHeaders.length) {
        return {
            valid: false,
            reason: types_2.WebhookValidationErrorReason.MissingHeaders,
            missingHeaders,
        };
    }
    else {
        return Object.assign(Object.assign(Object.assign({ valid: true }, headerValues), (headerValues.subTopic ? { subTopic: headerValues.subTopic } : {})), { topic: (0, registry_1.topicForStorage)(headerValues.topic) });
    }
}
//# sourceMappingURL=validate.js.map