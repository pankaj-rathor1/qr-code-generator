"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFactory = void 0;
const tslib_1 = require("tslib");
const http_1 = require("../../runtime/http");
const types_1 = require("../../runtime/crypto/types");
const logger_1 = require("../logger");
const types_2 = require("../types");
const hmac_validator_1 = require("../utils/hmac-validator");
const types_3 = require("./types");
function validateFactory(config) {
    return function validate(_a) {
        var { rawBody } = _a, adapterArgs = tslib_1.__rest(_a, ["rawBody"]);
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const request = yield (0, http_1.abstractConvertRequest)(adapterArgs);
            if (!rawBody.length) {
                return fail(types_3.FlowValidationErrorReason.MissingBody, config);
            }
            const hmac = (0, http_1.getHeader)(request.headers, types_2.ShopifyHeader.Hmac);
            if (!hmac) {
                return fail(types_3.FlowValidationErrorReason.MissingHmac, config);
            }
            if (yield (0, hmac_validator_1.validateHmacString)(config, rawBody, hmac, types_1.HashFormat.Base64)) {
                return succeed(config);
            }
            return fail(types_3.FlowValidationErrorReason.InvalidHmac, config);
        });
    };
}
exports.validateFactory = validateFactory;
function fail(reason, config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const log = (0, logger_1.logger)(config);
        yield log.debug('Flow request is not valid', { reason });
        return {
            valid: false,
            reason,
        };
    });
}
function succeed(config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const log = (0, logger_1.logger)(config);
        yield log.debug('Flow request is valid');
        return {
            valid: true,
        };
    });
}
//# sourceMappingURL=validate.js.map