import { generateHttpFetch } from './http-fetch.mjs';
import { CLIENT, CONTENT_TYPES, UNEXPECTED_CONTENT_TYPE_ERROR, GQL_API_ERROR, NO_DATA_OR_ERRORS_ERROR, RETRY_WAIT_TIME } from './constants.mjs';
import { validateRetries, formatErrorMessage, getErrorMessage, getKeyValueIfValid } from './utilities.mjs';

function createGraphQLClient({ headers, url, customFetchApi = fetch, retries = 0, logger, }) {
    validateRetries({ client: CLIENT, retries });
    const config = {
        headers,
        url,
        retries,
    };
    const clientLogger = generateClientLogger(logger);
    const httpFetch = generateHttpFetch({
        customFetchApi,
        clientLogger,
        defaultRetryWaitTime: RETRY_WAIT_TIME,
    });
    const fetch = generateFetch(httpFetch, config);
    const request = generateRequest(fetch);
    return {
        config,
        fetch,
        request,
    };
}
function generateClientLogger(logger) {
    return (logContent) => {
        if (logger) {
            logger(logContent);
        }
    };
}
async function processJSONResponse(response) {
    const { errors, data, extensions } = await response.json();
    return {
        ...getKeyValueIfValid("data", data),
        ...getKeyValueIfValid("extensions", extensions),
        ...(errors || !data
            ? {
                errors: {
                    networkStatusCode: response.status,
                    message: formatErrorMessage(errors ? GQL_API_ERROR : NO_DATA_OR_ERRORS_ERROR),
                    ...getKeyValueIfValid("graphQLErrors", errors),
                    response,
                },
            }
            : {}),
    };
}
function generateFetch(httpFetch, { url, headers, retries }) {
    return async (operation, options = {}) => {
        const { variables, headers: overrideHeaders, url: overrideUrl, retries: overrideRetries, } = options;
        const body = JSON.stringify({
            query: operation,
            variables,
        });
        validateRetries({ client: CLIENT, retries: overrideRetries });
        const flatHeaders = Object.fromEntries(Object.entries({ ...headers, ...overrideHeaders }).map(([key, value]) => [
            key,
            Array.isArray(value) ? value.join(", ") : value.toString(),
        ]));
        const fetchParams = [
            overrideUrl ?? url,
            {
                method: "POST",
                headers: flatHeaders,
                body,
            },
        ];
        return httpFetch(fetchParams, 1, overrideRetries ?? retries);
    };
}
function generateRequest(fetch) {
    return async (...props) => {
        try {
            const response = await fetch(...props);
            const { status, statusText } = response;
            const contentType = response.headers.get("content-type") || "";
            if (!response.ok) {
                return {
                    errors: {
                        networkStatusCode: status,
                        message: formatErrorMessage(statusText),
                        response,
                    },
                };
            }
            if (!contentType.includes(CONTENT_TYPES.json)) {
                return {
                    errors: {
                        networkStatusCode: status,
                        message: formatErrorMessage(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${contentType}`),
                        response,
                    },
                };
            }
            return processJSONResponse(response);
        }
        catch (error) {
            return {
                errors: {
                    message: getErrorMessage(error),
                },
            };
        }
    };
}

export { createGraphQLClient, generateClientLogger };
//# sourceMappingURL=graphql-client.mjs.map
