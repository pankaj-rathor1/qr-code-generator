/*! shopify/graphql-client@0.9.4 -- Copyright (c) 2023-present, Shopify Inc. -- license (MIT): https://github.com/Shopify/shopify-api-js/blob/main/LICENSE.md */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ShopifyGraphQLClient = {}));
})(this, (function (exports) { 'use strict';

    const CLIENT = "GraphQL Client";
    const MIN_RETRIES = 0;
    const MAX_RETRIES = 3;
    const GQL_API_ERROR = "An error occurred while fetching from the API. Review 'graphQLErrors' for details.";
    const UNEXPECTED_CONTENT_TYPE_ERROR = "Response returned unexpected Content-Type:";
    const NO_DATA_OR_ERRORS_ERROR = "An unknown error has occurred. The API did not return a data object or any errors in its response.";
    const CONTENT_TYPES = {
        json: "application/json",
        multipart: "multipart/mixed",
    };
    const RETRY_WAIT_TIME = 1000;
    const RETRIABLE_STATUS_CODES = [429, 503];

    function formatErrorMessage(message, client = CLIENT) {
        return message.startsWith(`${client}`) ? message : `${client}: ${message}`;
    }
    function getErrorMessage(error) {
        return error instanceof Error ? error.message : JSON.stringify(error);
    }
    function validateRetries({ client, retries, }) {
        if (retries !== undefined &&
            (typeof retries !== "number" ||
                retries < MIN_RETRIES ||
                retries > MAX_RETRIES)) {
            throw new Error(`${client}: The provided "retries" value (${retries}) is invalid - it cannot be less than ${MIN_RETRIES} or greater than ${MAX_RETRIES}`);
        }
    }
    function getKeyValueIfValid(key, value) {
        return value &&
            (typeof value !== "object" ||
                Array.isArray(value) ||
                (typeof value === "object" && Object.keys(value).length > 0))
            ? { [key]: value }
            : {};
    }

    function generateHttpFetch({ clientLogger, customFetchApi = fetch, client = CLIENT, defaultRetryWaitTime = RETRY_WAIT_TIME, retriableCodes = RETRIABLE_STATUS_CODES, }) {
        const httpFetch = async (requestParams, count, maxRetries) => {
            const nextCount = count + 1;
            const maxTries = maxRetries + 1;
            let response;
            try {
                response = await customFetchApi(...requestParams);
                clientLogger({
                    type: "HTTP-Response",
                    content: {
                        requestParams,
                        response,
                    },
                });
                if (!response.ok &&
                    retriableCodes.includes(response.status) &&
                    nextCount <= maxTries) {
                    throw new Error();
                }
                return response;
            }
            catch (error) {
                if (nextCount <= maxTries) {
                    const retryAfter = response?.headers.get("Retry-After");
                    await sleep(retryAfter ? parseInt(retryAfter, 10) : defaultRetryWaitTime);
                    clientLogger({
                        type: "HTTP-Retry",
                        content: {
                            requestParams,
                            lastResponse: response,
                            retryAttempt: count,
                            maxRetries,
                        },
                    });
                    return httpFetch(requestParams, nextCount, maxRetries);
                }
                throw new Error(formatErrorMessage(`${maxRetries > 0
                ? `Attempted maximum number of ${maxRetries} network retries. Last message - `
                : ""}${getErrorMessage(error)}`, client));
            }
        };
        return httpFetch;
    }
    async function sleep(waitTime) {
        return new Promise((resolve) => setTimeout(resolve, waitTime));
    }

    function createGraphQLClient({ headers, url, customFetchApi = fetch, retries = 0, logger, }) {
        validateRetries({ client: CLIENT, retries });
        const config = {
            headers,
            url,
            retries,
        };
        const clientLogger = generateClientLogger(logger);
        const httpFetch = generateHttpFetch({
            customFetchApi,
            clientLogger,
            defaultRetryWaitTime: RETRY_WAIT_TIME,
        });
        const fetch = generateFetch(httpFetch, config);
        const request = generateRequest(fetch);
        return {
            config,
            fetch,
            request,
        };
    }
    function generateClientLogger(logger) {
        return (logContent) => {
            if (logger) {
                logger(logContent);
            }
        };
    }
    async function processJSONResponse(response) {
        const { errors, data, extensions } = await response.json();
        return {
            ...getKeyValueIfValid("data", data),
            ...getKeyValueIfValid("extensions", extensions),
            ...(errors || !data
                ? {
                    errors: {
                        networkStatusCode: response.status,
                        message: formatErrorMessage(errors ? GQL_API_ERROR : NO_DATA_OR_ERRORS_ERROR),
                        ...getKeyValueIfValid("graphQLErrors", errors),
                        response,
                    },
                }
                : {}),
        };
    }
    function generateFetch(httpFetch, { url, headers, retries }) {
        return async (operation, options = {}) => {
            const { variables, headers: overrideHeaders, url: overrideUrl, retries: overrideRetries, } = options;
            const body = JSON.stringify({
                query: operation,
                variables,
            });
            validateRetries({ client: CLIENT, retries: overrideRetries });
            const flatHeaders = Object.fromEntries(Object.entries({ ...headers, ...overrideHeaders }).map(([key, value]) => [
                key,
                Array.isArray(value) ? value.join(", ") : value.toString(),
            ]));
            const fetchParams = [
                overrideUrl ?? url,
                {
                    method: "POST",
                    headers: flatHeaders,
                    body,
                },
            ];
            return httpFetch(fetchParams, 1, overrideRetries ?? retries);
        };
    }
    function generateRequest(fetch) {
        return async (...props) => {
            try {
                const response = await fetch(...props);
                const { status, statusText } = response;
                const contentType = response.headers.get("content-type") || "";
                if (!response.ok) {
                    return {
                        errors: {
                            networkStatusCode: status,
                            message: formatErrorMessage(statusText),
                            response,
                        },
                    };
                }
                if (!contentType.includes(CONTENT_TYPES.json)) {
                    return {
                        errors: {
                            networkStatusCode: status,
                            message: formatErrorMessage(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${contentType}`),
                            response,
                        },
                    };
                }
                return processJSONResponse(response);
            }
            catch (error) {
                return {
                    errors: {
                        message: getErrorMessage(error),
                    },
                };
            }
        };
    }

    exports.createGraphQLClient = createGraphQLClient;

}));
//# sourceMappingURL=graphql-client.js.map
