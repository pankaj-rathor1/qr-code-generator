'use strict';

var httpFetch = require('./http-fetch.js');
var constants = require('./constants.js');
var utilities = require('./utilities.js');

function createGraphQLClient({ headers, url, customFetchApi = fetch, retries = 0, logger, }) {
    utilities.validateRetries({ client: constants.CLIENT, retries });
    const config = {
        headers,
        url,
        retries,
    };
    const clientLogger = generateClientLogger(logger);
    const httpFetch$1 = httpFetch.generateHttpFetch({
        customFetchApi,
        clientLogger,
        defaultRetryWaitTime: constants.RETRY_WAIT_TIME,
    });
    const fetch = generateFetch(httpFetch$1, config);
    const request = generateRequest(fetch);
    return {
        config,
        fetch,
        request,
    };
}
function generateClientLogger(logger) {
    return (logContent) => {
        if (logger) {
            logger(logContent);
        }
    };
}
async function processJSONResponse(response) {
    const { errors, data, extensions } = await response.json();
    return {
        ...utilities.getKeyValueIfValid("data", data),
        ...utilities.getKeyValueIfValid("extensions", extensions),
        ...(errors || !data
            ? {
                errors: {
                    networkStatusCode: response.status,
                    message: utilities.formatErrorMessage(errors ? constants.GQL_API_ERROR : constants.NO_DATA_OR_ERRORS_ERROR),
                    ...utilities.getKeyValueIfValid("graphQLErrors", errors),
                    response,
                },
            }
            : {}),
    };
}
function generateFetch(httpFetch, { url, headers, retries }) {
    return async (operation, options = {}) => {
        const { variables, headers: overrideHeaders, url: overrideUrl, retries: overrideRetries, } = options;
        const body = JSON.stringify({
            query: operation,
            variables,
        });
        utilities.validateRetries({ client: constants.CLIENT, retries: overrideRetries });
        const flatHeaders = Object.fromEntries(Object.entries({ ...headers, ...overrideHeaders }).map(([key, value]) => [
            key,
            Array.isArray(value) ? value.join(", ") : value.toString(),
        ]));
        const fetchParams = [
            overrideUrl ?? url,
            {
                method: "POST",
                headers: flatHeaders,
                body,
            },
        ];
        return httpFetch(fetchParams, 1, overrideRetries ?? retries);
    };
}
function generateRequest(fetch) {
    return async (...props) => {
        try {
            const response = await fetch(...props);
            const { status, statusText } = response;
            const contentType = response.headers.get("content-type") || "";
            if (!response.ok) {
                return {
                    errors: {
                        networkStatusCode: status,
                        message: utilities.formatErrorMessage(statusText),
                        response,
                    },
                };
            }
            if (!contentType.includes(constants.CONTENT_TYPES.json)) {
                return {
                    errors: {
                        networkStatusCode: status,
                        message: utilities.formatErrorMessage(`${constants.UNEXPECTED_CONTENT_TYPE_ERROR} ${contentType}`),
                        response,
                    },
                };
            }
            return processJSONResponse(response);
        }
        catch (error) {
            return {
                errors: {
                    message: utilities.getErrorMessage(error),
                },
            };
        }
    };
}

exports.createGraphQLClient = createGraphQLClient;
exports.generateClientLogger = generateClientLogger;
//# sourceMappingURL=graphql-client.js.map
